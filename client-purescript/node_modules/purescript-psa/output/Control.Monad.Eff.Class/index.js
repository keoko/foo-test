// Generated by psc version 0.8.5.0
"use strict";
var Prelude = require("../Prelude");
var Control_Monad_Eff = require("../Control.Monad.Eff");

/**
 *  | The `MonadEff` class captures those monads which support native effects.
 *  |
 *  | Instances are provided for `Eff` itself, and the standard monad transformers.
 *  |
 *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
 *  | of type `Eff eff a` into the monad.
 *  |
 *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
 *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
 *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
 */
var MonadEff = function (__superclass_Prelude$dotMonad_0, liftEff) {
    this["__superclass_Prelude.Monad_0"] = __superclass_Prelude$dotMonad_0;
    this.liftEff = liftEff;
};
var monadEffEff = new MonadEff(function () {
    return Control_Monad_Eff.monadEff;
}, Prelude.id(Prelude.categoryFn));

/**
 *  | The `MonadEff` class captures those monads which support native effects.
 *  |
 *  | Instances are provided for `Eff` itself, and the standard monad transformers.
 *  |
 *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
 *  | of type `Eff eff a` into the monad.
 *  |
 *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
 *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
 *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
 */
var liftEff = function (dict) {
    return dict.liftEff;
};
module.exports = {
    MonadEff: MonadEff, 
    liftEff: liftEff, 
    monadEffEff: monadEffEff
};
