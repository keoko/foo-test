// Generated by psc version 0.8.5.0

/**
 *  | This module contains various types and functions to allow you to spawn and
 *  | interact with child processes.
 *  |
 *  | It is intended to be imported qualified, as follows:
 *  |
 *  | ```purescript
 *  | import Node.ChildProcess (ChildProcess(), CHILD_PROCESS())
 *  | import Node.ChildProcess as ChildProcess
 *  | ```
 *  |
 *  | The [Node.js documentation](https://nodejs.org/api/child_process.html)
 *  | will probably also be useful to read if you want to use this module.
 */
"use strict";
var $foreign = require("./foreign");
var Prelude = require("../Prelude");
var Control_Alt = require("../Control.Alt");
var Control_Bind = require("../Control.Bind");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Exception = require("../Control.Monad.Eff.Exception");
var Control_Monad_Eff_Exception_Unsafe = require("../Control.Monad.Eff.Exception.Unsafe");
var Data_StrMap = require("../Data.StrMap");
var Data_Function = require("../Data.Function");
var Data_Nullable = require("../Data.Nullable");
var Data_Maybe = require("../Data.Maybe");
var Data_Foreign = require("../Data.Foreign");
var Data_Posix = require("../Data.Posix");
var Data_Posix_Signal_1 = require("../Data.Posix.Signal");
var Data_Posix_Signal_1 = require("../Data.Posix.Signal");
var Unsafe_Coerce = require("../Unsafe.Coerce");
var Node_Buffer = require("../Node.Buffer");
var Node_FS = require("../Node.FS");
var Node_Stream = require("../Node.Stream");

/**
 *  | Behaviour for standard IO streams (eg, standard input, standard output) of
 *  | a child process.
 *  |
 *  | * `Pipe`: creates a pipe between the child and parent process, which can
 *  |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`
 *  |   functions.
 *  | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and
 *  |   connect it to the stream.
 *  | * `ShareStream`: Connect the supplied stream to the corresponding file
 *  |    descriptor in the child.
 *  | * `ShareFD`: Connect the supplied file descriptor (which should be open
 *  |   in the parent) to the corresponding file descriptor in the child.
 */
var Pipe = (function () {
    function Pipe() {

    };
    Pipe.value = new Pipe();
    return Pipe;
})();

/**
 *  | Behaviour for standard IO streams (eg, standard input, standard output) of
 *  | a child process.
 *  |
 *  | * `Pipe`: creates a pipe between the child and parent process, which can
 *  |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`
 *  |   functions.
 *  | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and
 *  |   connect it to the stream.
 *  | * `ShareStream`: Connect the supplied stream to the corresponding file
 *  |    descriptor in the child.
 *  | * `ShareFD`: Connect the supplied file descriptor (which should be open
 *  |   in the parent) to the corresponding file descriptor in the child.
 */
var Ignore = (function () {
    function Ignore() {

    };
    Ignore.value = new Ignore();
    return Ignore;
})();

/**
 *  | Behaviour for standard IO streams (eg, standard input, standard output) of
 *  | a child process.
 *  |
 *  | * `Pipe`: creates a pipe between the child and parent process, which can
 *  |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`
 *  |   functions.
 *  | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and
 *  |   connect it to the stream.
 *  | * `ShareStream`: Connect the supplied stream to the corresponding file
 *  |    descriptor in the child.
 *  | * `ShareFD`: Connect the supplied file descriptor (which should be open
 *  |   in the parent) to the corresponding file descriptor in the child.
 */
var ShareStream = (function () {
    function ShareStream(value0) {
        this.value0 = value0;
    };
    ShareStream.create = function (value0) {
        return new ShareStream(value0);
    };
    return ShareStream;
})();

/**
 *  | Behaviour for standard IO streams (eg, standard input, standard output) of
 *  | a child process.
 *  |
 *  | * `Pipe`: creates a pipe between the child and parent process, which can
 *  |   then be accessed as a `Stream` via the `stdin`, `stdout`, or `stderr`
 *  |   functions.
 *  | * `Ignore`: ignore this stream. This will cause Node to open /dev/null and
 *  |   connect it to the stream.
 *  | * `ShareStream`: Connect the supplied stream to the corresponding file
 *  |    descriptor in the child.
 *  | * `ShareFD`: Connect the supplied file descriptor (which should be open
 *  |   in the parent) to the corresponding file descriptor in the child.
 */
var ShareFD = (function () {
    function ShareFD(value0) {
        this.value0 = value0;
    };
    ShareFD.create = function (value0) {
        return new ShareFD(value0);
    };
    return ShareFD;
})();

/**
 *  | Specifies how a child process exited; normally (with an exit code), or
 *  | due to a signal.
 */
var Normally = (function () {
    function Normally(value0) {
        this.value0 = value0;
    };
    Normally.create = function (value0) {
        return new Normally(value0);
    };
    return Normally;
})();

/**
 *  | Specifies how a child process exited; normally (with an exit code), or
 *  | due to a signal.
 */
var BySignal = (function () {
    function BySignal(value0) {
        this.value0 = value0;
    };
    BySignal.create = function (value0) {
        return new BySignal(value0);
    };
    return BySignal;
})();
var ChildProcess = function (x) {
    return x;
};

/**
 *  | Convert a ChildProcess.Error to a standard Error, which can then be thrown
 *  | inside an Eff or Aff computation (for example).
 */
var toStandardError = Unsafe_Coerce.unsafeCoerce;
var toActualStdIOBehaviour = function (b) {
    if (b instanceof Pipe) {
        return Unsafe_Coerce.unsafeCoerce("pipe");
    };
    if (b instanceof Ignore) {
        return Unsafe_Coerce.unsafeCoerce("ignore");
    };
    if (b instanceof ShareFD) {
        return Unsafe_Coerce.unsafeCoerce(b.value0);
    };
    if (b instanceof ShareStream) {
        return Unsafe_Coerce.unsafeCoerce(b.value0);
    };
    throw new Error("Failed pattern match at Node.ChildProcess line 367, column 28 - line 372, column 3: " + [ b.constructor.name ]);
};
var toActualStdIOOptions = Prelude.map(Prelude.functorArray)(function ($31) {
    return Data_Nullable.toNullable(Prelude.map(Data_Maybe.functorMaybe)(toActualStdIOBehaviour)($31));
});

/**
 *  | Spawn a child process. Note that, in the event that a child process could
 *  | not be spawned (for example, if the executable was not found) this will
 *  | not throw an error. Instead, the `ChildProcess` will be created anyway,
 *  | but it will immediately emit an 'error' event.
 */
var spawn = function (cmd) {
    return function (args) {
        return function (opts) {
            var convertOpts = function (opts1) {
                return {
                    cwd: Data_Maybe.fromMaybe($foreign["undefined"])(opts1.cwd), 
                    stdio: toActualStdIOOptions(opts1.stdio), 
                    env: Data_Nullable.toNullable(opts1.env), 
                    detached: opts1.detached, 
                    uid: Data_Maybe.fromMaybe($foreign["undefined"])(opts1.uid), 
                    gid: Data_Maybe.fromMaybe($foreign["undefined"])(opts1.gid)
                };
            };
            return $foreign.spawnImpl(cmd)(args)(convertOpts(opts));
        };
    };
};
var showExit = new Prelude.Show(function (v) {
    if (v instanceof Normally) {
        return "Normally " + Prelude.show(Prelude.showInt)(v.value0);
    };
    if (v instanceof BySignal) {
        return "BySignal " + Prelude.show(Data_Posix_Signal_1.showSignal)(v.value0);
    };
    throw new Error("Failed pattern match at Node.ChildProcess line 147, column 3 - line 148, column 3: " + [ v.constructor.name ]);
});
var runChildProcess = function (v) {
    return v;
};

/**
 *  | Create pipes for each of the three standard IO streams.
 */
var pipe = Prelude.map(Prelude.functorArray)(Data_Maybe.Just.create)([ Pipe.value, Pipe.value, Pipe.value ]);

/**
 *  | The process ID of a child process. Note that if the process has already
 *  | exited, another process may have taken the same ID, so be careful!
 */
var pid = function ($32) {
    return (function (v) {
        return v.pid;
    })(runChildProcess($32));
};
var onMessage = $foreign.mkOnMessage(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
var mkExit = function (code) {
    return function (signal) {
        var fromSignal = Control_Bind[">=>"](Data_Maybe.bindMaybe)(Data_Nullable.toMaybe)(function ($33) {
            return Prelude.map(Data_Maybe.functorMaybe)(BySignal.create)(Data_Posix_Signal_1.fromString($33));
        });
        var fromCode = function ($34) {
            return Prelude.map(Data_Maybe.functorMaybe)(Normally.create)(Data_Nullable.toMaybe($34));
        };
        var $20 = Control_Alt["<|>"](Data_Maybe.altMaybe)(fromCode(code))(fromSignal(signal));
        if ($20 instanceof Data_Maybe.Just) {
            return $20.value0;
        };
        if ($20 instanceof Data_Maybe.Nothing) {
            return Control_Monad_Eff_Exception_Unsafe.unsafeThrow("Node.ChildProcess.mkExit: Invalid arguments");
        };
        throw new Error("Failed pattern match at Node.ChildProcess line 153, column 3 - line 156, column 3: " + [ $20.constructor.name ]);
    };
};
var onClose = $foreign.mkOnClose(mkExit);
var onExit = $foreign.mkOnExit(mkExit);
var mkEff = Unsafe_Coerce.unsafeCoerce;
var send = function (msg) {
    return function (handle) {
        return function (v) {
            return mkEff(function (v1) {
                return v.send(msg, handle);
            });
        };
    };
};
var missingStream = function (str) {
    return "Node.ChildProcess: stream not available: " + (str + ("\nThis is probably " + ("because you passed something other than Pipe to the stdio option when " + "you spawned it.")));
};

/**
 *  | The standard error stream of a child process. Note that this is only
 *  | available if the process was spawned with the stderr option set to "pipe".
 */
var stderr = function ($35) {
    return $foreign.unsafeFromNullable(missingStream("stderr"))((function (v) {
        return v.stderr;
    })(runChildProcess($35)));
};

/**
 *  | The standard input stream of a child process. Note that this is only
 *  | available if the process was spawned with the stdin option set to "pipe".
 */
var stdin = function ($36) {
    return $foreign.unsafeFromNullable(missingStream("stdin"))((function (v) {
        return v.stdin;
    })(runChildProcess($36)));
};

/**
 *  | The standard output stream of a child process. Note that this is only
 *  | available if the process was spawned with the stdout option set to "pipe".
 */
var stdout = function ($37) {
    return $foreign.unsafeFromNullable(missingStream("stdout"))((function (v) {
        return v.stdout;
    })(runChildProcess($37)));
};

/**
 *  | Send a signal to a child process. It's an unfortunate historical decision
 *  | that this function is called "kill", as sending a signal to a child
 *  | process won't necessarily kill it.
 */
var kill = function (sig) {
    return function (v) {
        return mkEff(function (v1) {
            return v.kill(Data_Posix_Signal_1.toString(sig));
        });
    };
};

/**
 *  | Share stdin with stdin, stdout with stdout, and stderr with stderr.
 */
var inherit = Prelude.map(Prelude.functorArray)(Data_Maybe.Just.create)([ new ShareStream($foreign.process.stdin), new ShareStream($foreign.process.stdout), new ShareStream($foreign.process.stderr) ]);

/**
 *  | Ignore all streams.
 */
var ignore = Prelude.map(Prelude.functorArray)(Data_Maybe.Just.create)([ Ignore.value, Ignore.value, Ignore.value ]);
var disconnect = function ($38) {
    return (function (v) {
        return v.disconnect;
    })(runChildProcess($38));
};
var defaultSpawnOptions = {
    cwd: Data_Maybe.Nothing.value, 
    stdio: pipe, 
    env: Data_Maybe.Nothing.value, 
    detached: false, 
    uid: Data_Maybe.Nothing.value, 
    gid: Data_Maybe.Nothing.value
};
var defaultExecOptions = {
    cwd: Data_Maybe.Nothing.value, 
    env: Data_Maybe.Nothing.value, 
    timeout: Data_Maybe.Nothing.value, 
    maxBuffer: Data_Maybe.Nothing.value, 
    killSignal: Data_Maybe.Nothing.value, 
    uid: Data_Maybe.Nothing.value, 
    gid: Data_Maybe.Nothing.value
};
var convertExecOptions = function (opts) {
    return Unsafe_Coerce.unsafeCoerce({
        cwd: Data_Maybe.fromMaybe($foreign["undefined"])(opts.cwd), 
        env: Data_Maybe.fromMaybe($foreign["undefined"])(opts.env), 
        timeout: Data_Maybe.fromMaybe($foreign["undefined"])(opts.timeout), 
        maxBuffer: Data_Maybe.fromMaybe($foreign["undefined"])(opts.maxBuffer), 
        killSignal: Data_Maybe.fromMaybe($foreign["undefined"])(opts.killSignal), 
        uid: Data_Maybe.fromMaybe($foreign["undefined"])(opts.uid), 
        gid: Data_Maybe.fromMaybe($foreign["undefined"])(opts.gid)
    });
};

/**
 *  | Similar to `spawn`, except that this variant will:
 *  | * run the given command with the shell,
 *  | * buffer output, and wait until the process has exited before calling the
 *  |   callback.
 *  |
 *  | Note that the child process will be killed if the amount of output exceeds
 *  | a certain threshold (the default is defined by Node.js).
 */
var exec = function (cmd) {
    return function (opts) {
        return function (callback) {
            return $foreign.execImpl(cmd)(convertExecOptions(opts))(function (err) {
                return function (stdout$prime) {
                    return function (stderr$prime) {
                        return callback({
                            error: Data_Nullable.toMaybe(err), 
                            stdout: stdout$prime, 
                            stderr: stderr$prime
                        });
                    };
                };
            });
        };
    };
};

/**
 *  | Like `exec`, except instead of using a shell, it passes the arguments
 *  | directly to the specified command.
 */
var execFile = function (cmd) {
    return function (args) {
        return function (opts) {
            return function (callback) {
                return $foreign.execFileImpl(cmd)(args)(convertExecOptions(opts))(function (err) {
                    return function (stdout$prime) {
                        return function (stderr$prime) {
                            return callback({
                                error: Data_Nullable.toMaybe(err), 
                                stdout: stdout$prime, 
                                stderr: stderr$prime
                            });
                        };
                    };
                });
            };
        };
    };
};
var connected = function (v) {
    return mkEff(function (v1) {
        return v.connected;
    });
};
module.exports = {
    Pipe: Pipe, 
    Ignore: Ignore, 
    ShareStream: ShareStream, 
    ShareFD: ShareFD, 
    Normally: Normally, 
    BySignal: BySignal, 
    ignore: ignore, 
    inherit: inherit, 
    pipe: pipe, 
    defaultExecOptions: defaultExecOptions, 
    execFile: execFile, 
    exec: exec, 
    defaultSpawnOptions: defaultSpawnOptions, 
    spawn: spawn, 
    onMessage: onMessage, 
    onClose: onClose, 
    onExit: onExit, 
    toStandardError: toStandardError, 
    disconnect: disconnect, 
    send: send, 
    kill: kill, 
    connected: connected, 
    pid: pid, 
    stdin: stdin, 
    stdout: stdout, 
    stderr: stderr, 
    showExit: showExit, 
    fork: $foreign.fork, 
    onError: $foreign.onError, 
    onDisconnect: $foreign.onDisconnect
};
