// Generated by psc version 0.8.5.0

/**
 *  | This module defines a type of sets as balanced 2-3 trees, based on
 *  | <http://www.cs.princeton.edu/~dpw/courses/cos326-12/ass/2-3-trees.pdf>
 *  |
 *  | Qualified import is encouraged, so as to avoid name clashes with other modules.
 */
"use strict";
var Prelude = require("../Prelude");
var Data_Foldable_1 = require("../Data.Foldable");
var Data_List_1 = require("../Data.List");
var Data_Monoid = require("../Data.Monoid");
var Data_Map = require("../Data.Map");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_ST = require("../Control.Monad.ST");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class");
var Data_Array = require("../Data.Array");
var Data_Array_ST = require("../Data.Array.ST");
var Data_Array_Unsafe = require("../Data.Array.Unsafe");
var Data_List_1 = require("../Data.List");
var Data_Either = require("../Data.Either");
var Data_Foldable_1 = require("../Data.Foldable");
var Data_Unfoldable = require("../Data.Unfoldable");

/**
 *  | `Set a` represents a set of values of type `a`
 */
var $$Set = (function () {
    function Set(value0) {
        this.value0 = value0;
    };
    Set.create = function (value0) {
        return new Set(value0);
    };
    return Set;
})();

/**
 *  | Form the union of two sets
 *  |
 *  | Running time: `O(n * log(m))`
 */
var union = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return new $$Set(Data_Map.union(dictOrd)(v.value0)(v1.value0));
        };
    };
};

/**
 *  | Convert a set to a list
 */
var toList = function (v) {
    return Data_Map.keys(v.value0);
};
var toArray = function (dictOrd) {
    return function ($57) {
        return Data_List_1.fromList(Data_Unfoldable.unfoldableArray)(toList($57));
    };
};

/**
 *  | Find the size of a set
 */
var size = function (v) {
    return Data_Map.size(v.value0);
};

/**
 *  | Create a set with one element
 */
var singleton = function (a) {
    return new $$Set(Data_Map.singleton(a)(Prelude.unit));
};
var showSet = function (dictShow) {
    return new Prelude.Show(function (s) {
        return "fromList " + Prelude.show(Data_List_1.showList(dictShow))(toList(s));
    });
};
var semigroupSet = function (dictOrd) {
    return new Prelude.Semigroup(union(dictOrd));
};

/**
 *  | Test if a value is a member of a set
 */
var member = function (dictOrd) {
    return function (a) {
        return function (v) {
            return Data_Map.member(dictOrd)(a)(v.value0);
        };
    };
};

/**
 *  | Test if a set is empty
 */
var isEmpty = function (v) {
    return Data_Map.isEmpty(v.value0);
};

/**
 *  | Insert a value into a set
 */
var insert = function (dictOrd) {
    return function (a) {
        return function (v) {
            return new $$Set(Data_Map.insert(dictOrd)(a)(Prelude.unit)(v.value0));
        };
    };
};
var foldableSet = new Data_Foldable_1.Foldable(function (dictMonoid) {
    return function (f) {
        return function ($58) {
            return Data_Foldable_1.foldMap(Data_List_1.foldableList)(dictMonoid)(f)(toList($58));
        };
    };
}, function (f) {
    return function (x) {
        return function ($59) {
            return Data_Foldable_1.foldl(Data_List_1.foldableList)(f)(x)(toList($59));
        };
    };
}, function (f) {
    return function (x) {
        return function ($60) {
            return Data_Foldable_1.foldr(Data_List_1.foldableList)(f)(x)(toList($60));
        };
    };
});
var eqSet = function (dictEq) {
    return new Prelude.Eq(function (v) {
        return function (v1) {
            return Prelude["=="](Data_Map.eqMap(dictEq)(Prelude.eqUnit))(v.value0)(v1.value0);
        };
    });
};
var ordSet = function (dictOrd) {
    return new Prelude.Ord(function () {
        return eqSet(dictOrd["__superclass_Prelude.Eq_0"]());
    }, function (s1) {
        return function (s2) {
            return Prelude.compare(Data_List_1.ordList(dictOrd))(toList(s1))(toList(s2));
        };
    });
};

/**
 *  | An empty set
 */
var empty = new $$Set(Data_Map.empty);

/**
 *  | Create a set from a foldable collection of elements
 */
var fromFoldable = function (dictFoldable) {
    return function (dictOrd) {
        return Data_Foldable_1.foldl(dictFoldable)(function (m) {
            return function (a) {
                return insert(dictOrd)(a)(m);
            };
        })(empty);
    };
};

/**
 *  | Create a set from a list of elements
 */
var fromList = function (dictOrd) {
    return fromFoldable(Data_List_1.foldableList)(dictOrd);
};

/**
 *  | The set of elements which are in both the first and second set
 */
var intersection = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            var rs = toArray(dictOrd)(s2);
            var rl = Data_Array.length(rs);
            var ls = toArray(dictOrd)(s1);
            var ll = Data_Array.length(ls);
            var intersect = function (acc) {
                var go = function (l) {
                    return function (r) {
                        var $50 = l < ll && r < rl;
                        if ($50) {
                            var $51 = Prelude.compare(dictOrd)(ls[l])(rs[r]);
                            if ($51 instanceof Prelude.EQ) {
                                return function __do() {
                                    Data_Array_ST.pushSTArray(acc)(ls[l])();
                                    return new Data_Either.Left({
                                        a: l + 1 | 0, 
                                        b: r + 1 | 0
                                    });
                                };
                            };
                            if ($51 instanceof Prelude.LT) {
                                return Prelude.pure(Control_Monad_Eff.applicativeEff)(new Data_Either.Left({
                                    a: l + 1 | 0, 
                                    b: r
                                }));
                            };
                            if ($51 instanceof Prelude.GT) {
                                return Prelude.pure(Control_Monad_Eff.applicativeEff)(new Data_Either.Left({
                                    a: l, 
                                    b: r + 1 | 0
                                }));
                            };
                            throw new Error("Failed pattern match at Data.Set line 148, column 12 - line 154, column 7: " + [ $51.constructor.name ]);
                        };
                        if (!$50) {
                            return Prelude.pure(Control_Monad_Eff.applicativeEff)(new Data_Either.Right(acc));
                        };
                        throw new Error("Failed pattern match at Data.Set line 147, column 7 - line 156, column 1: " + [ $50.constructor.name ]);
                    };
                };
                return Control_Monad_Rec_Class.tailRecM2(Control_Monad_Rec_Class.monadRecEff)(go)(0)(0);
            };
            return fromFoldable(Data_Foldable_1.foldableArray)(dictOrd)(Control_Monad_Eff.runPure(Data_Array_ST.runSTArray(Prelude[">>="](Control_Monad_Eff.bindEff)(Data_Array_ST.emptySTArray)(intersect))));
        };
    };
};
var monoidSet = function (dictOrd) {
    return new Data_Monoid.Monoid(function () {
        return semigroupSet(dictOrd);
    }, empty);
};

/**
 *  | Form the union of a collection of sets
 */
var unions = function (dictOrd) {
    return Data_Foldable_1.foldl(Data_List_1.foldableList)(union(dictOrd))(empty);
};

/**
 *  | Delete a value from a set
 */
var $$delete = function (dictOrd) {
    return function (a) {
        return function (v) {
            return new $$Set(Data_Map["delete"](dictOrd)(a)(v.value0));
        };
    };
};

/**
 *  | Form the set difference
 */
var difference = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            return Data_Foldable_1.foldl(Data_List_1.foldableList)(Prelude.flip($$delete(dictOrd)))(s1)(toList(s2));
        };
    };
};

/**
 *  | True if and only if every element in the first set
 *  | is an element of the second set
 */
var subset = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            return isEmpty(difference(dictOrd)(s1)(s2));
        };
    };
};

/**
 *  | True if and only if the first set is a subset of the second set
 *  | and the sets are not equal
 */
var properSubset = function (dictOrd) {
    return function (s1) {
        return function (s2) {
            return subset(dictOrd)(s1)(s2) && Prelude["/="](eqSet(dictOrd["__superclass_Prelude.Eq_0"]()))(s1)(s2);
        };
    };
};

/**
 *  | Check whether the underlying tree satisfies the 2-3 invariant
 *  |
 *  | This function is provided for internal use.
 */
var checkValid = function (v) {
    return Data_Map.checkValid(v.value0);
};
module.exports = {
    intersection: intersection, 
    properSubset: properSubset, 
    subset: subset, 
    difference: difference, 
    unions: unions, 
    union: union, 
    size: size, 
    fromList: fromList, 
    toList: toList, 
    fromFoldable: fromFoldable, 
    "delete": $$delete, 
    member: member, 
    insert: insert, 
    checkValid: checkValid, 
    singleton: singleton, 
    isEmpty: isEmpty, 
    empty: empty, 
    eqSet: eqSet, 
    showSet: showSet, 
    ordSet: ordSet, 
    monoidSet: monoidSet, 
    semigroupSet: semigroupSet, 
    foldableSet: foldableSet
};
