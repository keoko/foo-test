// Generated by psc version 0.8.5.0
"use strict";
var $foreign = require("./foreign");

/**
 *  | The `Unit` type has a single inhabitant, called `unit`. It represents
 *  | values with no computational content.
 *  |
 *  | `Unit` is often used, wrapped in a monadic type constructor, as the
 *  | return type of a computation where only
 *  | the _effects_ are important.
 */
var Unit = function (x) {
    return x;
};

/**
 *  | The `Ordering` data type represents the three possible outcomes of
 *  | comparing two values:
 *  |
 *  | `LT` - The first value is _less than_ the second.
 *  | `GT` - The first value is _greater than_ the second.
 *  | `EQ` - The first value is _equal to_ the second.
 */
var LT = (function () {
    function LT() {

    };
    LT.value = new LT();
    return LT;
})();

/**
 *  | The `Ordering` data type represents the three possible outcomes of
 *  | comparing two values:
 *  |
 *  | `LT` - The first value is _less than_ the second.
 *  | `GT` - The first value is _greater than_ the second.
 *  | `EQ` - The first value is _equal to_ the second.
 */
var GT = (function () {
    function GT() {

    };
    GT.value = new GT();
    return GT;
})();

/**
 *  | The `Ordering` data type represents the three possible outcomes of
 *  | comparing two values:
 *  |
 *  | `LT` - The first value is _less than_ the second.
 *  | `GT` - The first value is _greater than_ the second.
 *  | `EQ` - The first value is _equal to_ the second.
 */
var EQ = (function () {
    function EQ() {

    };
    EQ.value = new EQ();
    return EQ;
})();

/**
 *  | A `Semigroupoid` is similar to a [`Category`](#category) but does not
 *  | require an identity element `id`, just composable morphisms.
 *  |
 *  | `Semigroupoid`s must satisfy the following law:
 *  |
 *  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
 *  |
 *  | One example of a `Semigroupoid` is the function type constructor `(->)`,
 *  | with `(<<<)` defined as function composition.
 */
var Semigroupoid = function (compose) {
    this.compose = compose;
};

/**
 *  | `Category`s consist of objects and composable morphisms between them, and
 *  | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`
 *  | must have an identity element.
 *  |
 *  | Instances must satisfy the following law in addition to the
 *  | `Semigroupoid` law:
 *  |
 *  | - Identity: `id <<< p = p <<< id = p`
 */
var Category = function (__superclass_Prelude$dotSemigroupoid_0, id) {
    this["__superclass_Prelude.Semigroupoid_0"] = __superclass_Prelude$dotSemigroupoid_0;
    this.id = id;
};

/**
 *  | A `Functor` is a type constructor which supports a mapping operation
 *  | `(<$>)`.
 *  |
 *  | `(<$>)` can be used to turn functions `a -> b` into functions
 *  | `f a -> f b` whose argument and return types use the type constructor `f`
 *  | to represent some computational context.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Identity: `(<$>) id = id`
 *  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
 */
var Functor = function (map) {
    this.map = map;
};

/**
 *  | The `Apply` class provides the `(<*>)` which is used to apply a function
 *  | to an argument under a type constructor.
 *  |
 *  | `Apply` can be used to lift functions of two or more arguments to work on
 *  | values wrapped with the type constructor `f`. It might also be understood
 *  | in terms of the `lift2` function:
 *  |
 *  | ```purescript
 *  | lift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c
 *  | lift2 f a b = f <$> a <*> b
 *  | ```
 *  |
 *  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts
 *  | the function application operator `($)` to arguments wrapped with the
 *  | type constructor `f`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Functor`
 *  | laws:
 *  |
 *  | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
 *  |
 *  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 */
var Apply = function (__superclass_Prelude$dotFunctor_0, apply) {
    this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    this.apply = apply;
};

/**
 *  | The `Applicative` type class extends the [`Apply`](#apply) type class
 *  | with a `pure` function, which can be used to create values of type `f a`
 *  | from values of type `a`.
 *  |
 *  | Where [`Apply`](#apply) provides the ability to lift functions of two or
 *  | more arguments to functions whose arguments are wrapped using `f`, and
 *  | [`Functor`](#functor) provides the ability to lift functions of one
 *  | argument, `pure` can be seen as the function which lifts functions of
 *  | _zero_ arguments. That is, `Applicative` functors support a lifting
 *  | operation for any number of function arguments.
 *  |
 *  | Instances must satisfy the following laws in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Identity: `(pure id) <*> v = v`
 *  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
 *  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
 *  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
 */
var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
    this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    this.pure = pure;
};

/**
 *  | The `Bind` type class extends the [`Apply`](#apply) type class with a
 *  | "bind" operation `(>>=)` which composes computations in sequence, using
 *  | the return value of one computation to determine the next computation.
 *  |
 *  | The `>>=` operator can also be expressed using `do` notation, as follows:
 *  |
 *  | ```purescript
 *  | x >>= f = do y <- x
 *  |              f y
 *  | ```
 *  |
 *  | where the function argument of `f` is given the name `y`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Associativity: `(x >>= f) >>= g = x >>= (\k => f k >>= g)`
 *  |
 *  | Associativity tells us that we can regroup operations which use `do`
 *  | notation so that we can unambiguously write, for example:
 *  |
 *  | ```purescript
 *  | do x <- m1
 *  |    y <- m2 x
 *  |    m3 x y
 *  | ```
 */
var Bind = function (__superclass_Prelude$dotApply_0, bind) {
    this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    this.bind = bind;
};

/**
 *  | The `Monad` type class combines the operations of the `Bind` and
 *  | `Applicative` type classes. Therefore, `Monad` instances represent type
 *  | constructors which support sequential composition, and also lifting of
 *  | functions of arbitrary arity.
 *  |
 *  | Instances must satisfy the following laws in addition to the
 *  | `Applicative` and `Bind` laws:
 *  |
 *  | - Left Identity: `pure x >>= f = f x`
 *  | - Right Identity: `x >>= pure = x`
 */
var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
    this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
    this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
};

/**
 *  | The `Semigroup` type class identifies an associative operation on a type.
 *  |
 *  | Instances are required to satisfy the following law:
 *  |
 *  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
 *  |
 *  | One example of a `Semigroup` is `String`, with `(<>)` defined as string
 *  | concatenation.
 */
var Semigroup = function (append) {
    this.append = append;
};

/**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihiliation: `zero * a = a * zero = zero`
 */
var Semiring = function (add, mul, one, zero) {
    this.add = add;
    this.mul = mul;
    this.one = one;
    this.zero = zero;
};

/**
 *  | The `Ring` class is for types that support addition, multiplication,
 *  | and subtraction operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Additive inverse: `a - a = (zero - a) + a = zero`
 */
var Ring = function (__superclass_Prelude$dotSemiring_0, sub) {
    this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
    this.sub = sub;
};

/**
 *  | The `ModuloSemiring` class is for types that support addition,
 *  | multiplication, division, and modulo (division remainder) operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Remainder: ``a / b * b + (a `mod` b) = a``
 */
var ModuloSemiring = function (__superclass_Prelude$dotSemiring_0, div, mod) {
    this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
    this.div = div;
    this.mod = mod;
};

/**
 *  | A `Ring` where every nonzero element has a multiplicative inverse.
 *  |
 *  | Instances must satisfy the following law in addition to the `Ring` and
 *  | `ModuloSemiring` laws:
 *  |
 *  | - Multiplicative inverse: `(one / x) * x = one`
 *  |
 *  | As a consequence of this ```a `mod` b = zero``` as no divide operation
 *  | will have a remainder.
 */
var DivisionRing = function (__superclass_Prelude$dotModuloSemiring_1, __superclass_Prelude$dotRing_0) {
    this["__superclass_Prelude.ModuloSemiring_1"] = __superclass_Prelude$dotModuloSemiring_1;
    this["__superclass_Prelude.Ring_0"] = __superclass_Prelude$dotRing_0;
};

/**
 *  | The `Num` class is for types that are commutative fields.
 *  |
 *  | Instances must satisfy the following law in addition to the
 *  | `DivisionRing` laws:
 *  |
 *  | - Commutative multiplication: `a * b = b * a`
 */
var Num = function (__superclass_Prelude$dotDivisionRing_0) {
    this["__superclass_Prelude.DivisionRing_0"] = __superclass_Prelude$dotDivisionRing_0;
};

/**
 *  | The `Eq` type class represents types which support decidable equality.
 *  |
 *  | `Eq` instances should satisfy the following laws:
 *  |
 *  | - Reflexivity: `x == x = true`
 *  | - Symmetry: `x == y = y == x`
 *  | - Transitivity: if `x == y` and `y == z` then `x == z`
 */
var Eq = function (eq) {
    this.eq = eq;
};

/**
 *  | The `Ord` type class represents types which support comparisons with a
 *  | _total order_.
 *  |
 *  | `Ord` instances should satisfy the laws of total orderings:
 *  |
 *  | - Reflexivity: `a <= a`
 *  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
 *  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
 */
var Ord = function (__superclass_Prelude$dotEq_0, compare) {
    this["__superclass_Prelude.Eq_0"] = __superclass_Prelude$dotEq_0;
    this.compare = compare;
};

/**
 *  | The `Bounded` type class represents types that are finite.
 *  |
 *  | Although there are no "internal" laws for `Bounded`, every value of `a`
 *  | should be considered less than or equal to `top` by some means, and greater
 *  | than or equal to `bottom`.
 *  |
 *  | The lack of explicit `Ord` constraint allows flexibility in the use of
 *  | `Bounded` so it can apply to total and partially ordered sets, boolean
 *  | algebras, etc.
 */
var Bounded = function (bottom, top) {
    this.bottom = bottom;
    this.top = top;
};

/**
 *  | The `BoundedOrd` type class represents totally ordered finite data types.
 *  |
 *  | Instances should satisfy the following law in addition to the `Ord` laws:
 *  |
 *  | - Ordering: `bottom <= a <= top`
 */
var BoundedOrd = function (__superclass_Prelude$dotBounded_0, __superclass_Prelude$dotOrd_1) {
    this["__superclass_Prelude.Bounded_0"] = __superclass_Prelude$dotBounded_0;
    this["__superclass_Prelude.Ord_1"] = __superclass_Prelude$dotOrd_1;
};

/**
 *  | The `BooleanAlgebra` type class represents types that behave like boolean
 *  | values.
 *  |
 *  | Instances should satisfy the following laws in addition to the `Bounded`
 *  | laws:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Distributivity:
 *  |   - `a && (b || c) = (a && b) || (a && c)`
 *  |   - `a || (b && c) = (a || b) && (a || c)`
 *  | - Identity:
 *  |   - `a || bottom = a`
 *  |   - `a && top = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Annhiliation:
 *  |   - `a || top = top`
 *  | - Complementation:
 *  |   - `a && not a = bottom`
 *  |   - `a || not a = top`
 */
var BooleanAlgebra = function (__superclass_Prelude$dotBounded_0, conj, disj, not) {
    this["__superclass_Prelude.Bounded_0"] = __superclass_Prelude$dotBounded_0;
    this.conj = conj;
    this.disj = disj;
    this.not = not;
};

/**
 *  | The `Show` type class represents those types which can be converted into
 *  | a human-readable `String` representation.
 *  |
 *  | While not required, it is recommended that for any expression `x`, the
 *  | string `show x` be executable PureScript code which evaluates to the same
 *  | value as the expression `x`.
 */
var Show = function (show) {
    this.show = show;
};

/**
 *  | Applies a function to its argument.
 *  |
 *  | ```purescript
 *  | length $ groupBy productCategory $ filter isInStock $ products
 *  | ```
 *  |
 *  | is equivalent to:
 *  |
 *  | ```purescript
 *  | length (groupBy productCategory (filter isInStock products))
 *  | ```
 *  |
 *  | `($)` is different from [`(#)`](#-2) because it is right-infix instead of
 *  | left: `a $ b $ c $ d x = a $ (b $ (c $ (d $ x))) = a (b (c (d x)))`
 */
var $dollar = function (f) {
    return function (x) {
        return f(x);
    };
};

/**
 *  | Applies an argument to a function.
 *  |
 *  | ```purescript
 *  | products # filter isInStock # groupBy productCategory # length
 *  | ```
 *  |
 *  | is equivalent to:
 *  |
 *  | ```purescript
 *  | length (groupBy productCategory (filter isInStock products))
 *  | ```
 *  |
 *  | `(#)` is different from [`($)`](#-1) because it is left-infix instead of
 *  | right: `x # a # b # c # d = (((x # a) # b) # c) # d = d (c (b (a x)))`
 */
var $hash = function (x) {
    return function (f) {
        return f(x);
    };
};

/**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihiliation: `zero * a = a * zero = zero`
 */
var zero = function (dict) {
    return dict.zero;
};
var unsafeCompare = $foreign.unsafeCompareImpl(LT.value)(EQ.value)(GT.value);

/**
 *  | `unit` is the sole inhabitant of the `Unit` type.
 */
var unit = {};

/**
 *  | The `Bounded` type class represents types that are finite.
 *  |
 *  | Although there are no "internal" laws for `Bounded`, every value of `a`
 *  | should be considered less than or equal to `top` by some means, and greater
 *  | than or equal to `bottom`.
 *  |
 *  | The lack of explicit `Ord` constraint allows flexibility in the use of
 *  | `Bounded` so it can apply to total and partially ordered sets, boolean
 *  | algebras, etc.
 */
var top = function (dict) {
    return dict.top;
};

/**
 *  | The `Ring` class is for types that support addition, multiplication,
 *  | and subtraction operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Additive inverse: `a - a = (zero - a) + a = zero`
 */
var sub = function (dict) {
    return dict.sub;
};

/**
 *  | `(-)` is an alias for `sub`.
 */
var $minus = function (dictRing) {
    return sub(dictRing);
};
var showUnit = new Show(function (v) {
    return "unit";
});
var showString = new Show($foreign.showStringImpl);
var showOrdering = new Show(function (v) {
    if (v instanceof LT) {
        return "LT";
    };
    if (v instanceof GT) {
        return "GT";
    };
    if (v instanceof EQ) {
        return "EQ";
    };
    throw new Error("Failed pattern match at Prelude line 864, column 3 - line 865, column 3: " + [ v.constructor.name ]);
});
var showNumber = new Show($foreign.showNumberImpl);
var showInt = new Show($foreign.showIntImpl);
var showChar = new Show($foreign.showCharImpl);
var showBoolean = new Show(function (v) {
    if (v) {
        return "true";
    };
    if (!v) {
        return "false";
    };
    throw new Error("Failed pattern match at Prelude line 842, column 3 - line 843, column 3: " + [ v.constructor.name ]);
});

/**
 *  | The `Show` type class represents those types which can be converted into
 *  | a human-readable `String` representation.
 *  |
 *  | While not required, it is recommended that for any expression `x`, the
 *  | string `show x` be executable PureScript code which evaluates to the same
 *  | value as the expression `x`.
 */
var show = function (dict) {
    return dict.show;
};
var showArray = function (dictShow) {
    return new Show($foreign.showArrayImpl(show(dictShow)));
};
var semiringUnit = new Semiring(function (v) {
    return function (v1) {
        return unit;
    };
}, function (v) {
    return function (v1) {
        return unit;
    };
}, unit, unit);
var semiringNumber = new Semiring($foreign.numAdd, $foreign.numMul, 1.0, 0.0);
var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);
var semigroupoidFn = new Semigroupoid(function (f) {
    return function (g) {
        return function (x) {
            return f(g(x));
        };
    };
});
var semigroupUnit = new Semigroup(function (v) {
    return function (v1) {
        return unit;
    };
});
var semigroupString = new Semigroup($foreign.concatString);
var semigroupOrdering = new Semigroup(function (v) {
    return function (v1) {
        if (v instanceof LT) {
            return LT.value;
        };
        if (v instanceof GT) {
            return GT.value;
        };
        if (v instanceof EQ) {
            return v1;
        };
        throw new Error("Failed pattern match at Prelude line 414, column 3 - line 415, column 3: " + [ v.constructor.name, v1.constructor.name ]);
    };
});
var semigroupArray = new Semigroup($foreign.concatArray);
var ringUnit = new Ring(function () {
    return semiringUnit;
}, function (v) {
    return function (v1) {
        return unit;
    };
});
var ringNumber = new Ring(function () {
    return semiringNumber;
}, $foreign.numSub);
var ringInt = new Ring(function () {
    return semiringInt;
}, $foreign.intSub);

/**
 *  | The `Applicative` type class extends the [`Apply`](#apply) type class
 *  | with a `pure` function, which can be used to create values of type `f a`
 *  | from values of type `a`.
 *  |
 *  | Where [`Apply`](#apply) provides the ability to lift functions of two or
 *  | more arguments to functions whose arguments are wrapped using `f`, and
 *  | [`Functor`](#functor) provides the ability to lift functions of one
 *  | argument, `pure` can be seen as the function which lifts functions of
 *  | _zero_ arguments. That is, `Applicative` functors support a lifting
 *  | operation for any number of function arguments.
 *  |
 *  | Instances must satisfy the following laws in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Identity: `(pure id) <*> v = v`
 *  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
 *  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
 *  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
 */
var pure = function (dict) {
    return dict.pure;
};

/**
 *  | `return` is an alias for `pure`.
 */
var $$return = function (dictApplicative) {
    return pure(dictApplicative);
};

/**
 *  | An alias for `true`, which can be useful in guard clauses:
 *  |
 *  | ```purescript
 *  | max x y | x >= y    = x
 *  |         | otherwise = y
 *  | ```
 */
var otherwise = true;

/**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihiliation: `zero * a = a * zero = zero`
 */
var one = function (dict) {
    return dict.one;
};

/**
 *  | The `BooleanAlgebra` type class represents types that behave like boolean
 *  | values.
 *  |
 *  | Instances should satisfy the following laws in addition to the `Bounded`
 *  | laws:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Distributivity:
 *  |   - `a && (b || c) = (a && b) || (a && c)`
 *  |   - `a || (b && c) = (a || b) && (a || c)`
 *  | - Identity:
 *  |   - `a || bottom = a`
 *  |   - `a && top = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Annhiliation:
 *  |   - `a || top = top`
 *  | - Complementation:
 *  |   - `a && not a = bottom`
 *  |   - `a || not a = top`
 */
var not = function (dict) {
    return dict.not;
};

/**
 *  | `negate x` can be used as a shorthand for `zero - x`.
 */
var negate = function (dictRing) {
    return function (a) {
        return $minus(dictRing)(zero(dictRing["__superclass_Prelude.Semiring_0"]()))(a);
    };
};

/**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihiliation: `zero * a = a * zero = zero`
 */
var mul = function (dict) {
    return dict.mul;
};

/**
 *  | `(*)` is an alias for `mul`.
 */
var $times = function (dictSemiring) {
    return mul(dictSemiring);
};
var moduloSemiringUnit = new ModuloSemiring(function () {
    return semiringUnit;
}, function (v) {
    return function (v1) {
        return unit;
    };
}, function (v) {
    return function (v1) {
        return unit;
    };
});
var moduloSemiringNumber = new ModuloSemiring(function () {
    return semiringNumber;
}, $foreign.numDiv, function (v) {
    return function (v1) {
        return 0.0;
    };
});
var moduloSemiringInt = new ModuloSemiring(function () {
    return semiringInt;
}, $foreign.intDiv, $foreign.intMod);

/**
 *  | The `ModuloSemiring` class is for types that support addition,
 *  | multiplication, division, and modulo (division remainder) operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Remainder: ``a / b * b + (a `mod` b) = a``
 */
var mod = function (dict) {
    return dict.mod;
};

/**
 *  | A `Functor` is a type constructor which supports a mapping operation
 *  | `(<$>)`.
 *  |
 *  | `(<$>)` can be used to turn functions `a -> b` into functions
 *  | `f a -> f b` whose argument and return types use the type constructor `f`
 *  | to represent some computational context.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Identity: `(<$>) id = id`
 *  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
 */
var map = function (dict) {
    return dict.map;
};

/**
 *  | `(<$>)` is an alias for `map`
 */
var $less$dollar$greater = function (dictFunctor) {
    return map(dictFunctor);
};

/**
 *  | `(<#>)` is `(<$>)` with its arguments reversed. For example:
 *  |
 *  | ```purescript
 *  | [1, 2, 3] <#> \n -> n * n
 *  | ```
 */
var $less$hash$greater = function (dictFunctor) {
    return function (fa) {
        return function (f) {
            return $less$dollar$greater(dictFunctor)(f)(fa);
        };
    };
};

/**
 *  | `Category`s consist of objects and composable morphisms between them, and
 *  | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`
 *  | must have an identity element.
 *  |
 *  | Instances must satisfy the following law in addition to the
 *  | `Semigroupoid` law:
 *  |
 *  | - Identity: `id <<< p = p <<< id = p`
 */
var id = function (dict) {
    return dict.id;
};
var functorArray = new Functor($foreign.arrayMap);

/**
 *  | Flips the order of the arguments to a function of two arguments.
 *  |
 *  | ```purescript
 *  | flip const 1 2 = const 2 1 = 2
 *  | ```
 */
var flip = function (f) {
    return function (b) {
        return function (a) {
            return f(a)(b);
        };
    };
};
var eqUnit = new Eq(function (v) {
    return function (v1) {
        return true;
    };
});
var ordUnit = new Ord(function () {
    return eqUnit;
}, function (v) {
    return function (v1) {
        return EQ.value;
    };
});
var eqString = new Eq($foreign.refEq);
var ordString = new Ord(function () {
    return eqString;
}, unsafeCompare);
var eqOrdering = new Eq(function (v) {
    return function (v1) {
        if (v instanceof LT && v1 instanceof LT) {
            return true;
        };
        if (v instanceof GT && v1 instanceof GT) {
            return true;
        };
        if (v instanceof EQ && v1 instanceof EQ) {
            return true;
        };
        return false;
    };
});
var ordOrdering = new Ord(function () {
    return eqOrdering;
}, function (v) {
    return function (v1) {
        if (v instanceof LT && v1 instanceof LT) {
            return EQ.value;
        };
        if (v instanceof EQ && v1 instanceof EQ) {
            return EQ.value;
        };
        if (v instanceof GT && v1 instanceof GT) {
            return EQ.value;
        };
        if (v instanceof LT) {
            return LT.value;
        };
        if (v instanceof EQ && v1 instanceof LT) {
            return GT.value;
        };
        if (v instanceof EQ && v1 instanceof GT) {
            return LT.value;
        };
        if (v instanceof GT) {
            return GT.value;
        };
        throw new Error("Failed pattern match at Prelude line 669, column 3 - line 670, column 3: " + [ v.constructor.name, v1.constructor.name ]);
    };
});
var eqNumber = new Eq($foreign.refEq);
var ordNumber = new Ord(function () {
    return eqNumber;
}, unsafeCompare);
var eqInt = new Eq($foreign.refEq);
var ordInt = new Ord(function () {
    return eqInt;
}, unsafeCompare);
var eqChar = new Eq($foreign.refEq);
var ordChar = new Ord(function () {
    return eqChar;
}, unsafeCompare);
var eqBoolean = new Eq($foreign.refEq);
var ordBoolean = new Ord(function () {
    return eqBoolean;
}, unsafeCompare);

/**
 *  | The `Eq` type class represents types which support decidable equality.
 *  |
 *  | `Eq` instances should satisfy the following laws:
 *  |
 *  | - Reflexivity: `x == x = true`
 *  | - Symmetry: `x == y = y == x`
 *  | - Transitivity: if `x == y` and `y == z` then `x == z`
 */
var eq = function (dict) {
    return dict.eq;
};

/**
 *  | `(==)` is an alias for `eq`. Tests whether one value is equal to another.
 */
var $eq$eq = function (dictEq) {
    return eq(dictEq);
};
var eqArray = function (dictEq) {
    return new Eq($foreign.eqArrayImpl($eq$eq(dictEq)));
};
var divisionRingUnit = new DivisionRing(function () {
    return moduloSemiringUnit;
}, function () {
    return ringUnit;
});
var numUnit = new Num(function () {
    return divisionRingUnit;
});
var divisionRingNumber = new DivisionRing(function () {
    return moduloSemiringNumber;
}, function () {
    return ringNumber;
});
var numNumber = new Num(function () {
    return divisionRingNumber;
});

/**
 *  | The `ModuloSemiring` class is for types that support addition,
 *  | multiplication, division, and modulo (division remainder) operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Remainder: ``a / b * b + (a `mod` b) = a``
 */
var div = function (dict) {
    return dict.div;
};

/**
 *  | `(/)` is an alias for `div`.
 */
var $div = function (dictModuloSemiring) {
    return div(dictModuloSemiring);
};

/**
 *  | The `BooleanAlgebra` type class represents types that behave like boolean
 *  | values.
 *  |
 *  | Instances should satisfy the following laws in addition to the `Bounded`
 *  | laws:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Distributivity:
 *  |   - `a && (b || c) = (a && b) || (a && c)`
 *  |   - `a || (b && c) = (a || b) && (a || c)`
 *  | - Identity:
 *  |   - `a || bottom = a`
 *  |   - `a && top = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Annhiliation:
 *  |   - `a || top = top`
 *  | - Complementation:
 *  |   - `a && not a = bottom`
 *  |   - `a || not a = top`
 */
var disj = function (dict) {
    return dict.disj;
};

/**
 *  | `(||)` is an alias for `disj`.
 */
var $bar$bar = function (dictBooleanAlgebra) {
    return disj(dictBooleanAlgebra);
};

/**
 *  | Returns its first argument and ignores its second.
 *  |
 *  | ```purescript
 *  | const 1 "hello" = 1
 *  | ```
 */
var $$const = function (a) {
    return function (v) {
        return a;
    };
};

/**
 *  | The `void` function is used to ignore the type wrapped by a
 *  | [`Functor`](#functor), replacing it with `Unit` and keeping only the type
 *  | information provided by the type constructor itself.
 *  |
 *  | `void` is often useful when using `do` notation to change the return type
 *  | of a monadic computation:
 *  |
 *  | ```purescript
 *  | main = forE 1 10 \n -> void do
 *  |   print n
 *  |   print (n * n)
 *  | ```
 */
var $$void = function (dictFunctor) {
    return function (fa) {
        return $less$dollar$greater(dictFunctor)($$const(unit))(fa);
    };
};

/**
 *  | The `BooleanAlgebra` type class represents types that behave like boolean
 *  | values.
 *  |
 *  | Instances should satisfy the following laws in addition to the `Bounded`
 *  | laws:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Distributivity:
 *  |   - `a && (b || c) = (a && b) || (a && c)`
 *  |   - `a || (b && c) = (a || b) && (a || c)`
 *  | - Identity:
 *  |   - `a || bottom = a`
 *  |   - `a && top = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Annhiliation:
 *  |   - `a || top = top`
 *  | - Complementation:
 *  |   - `a && not a = bottom`
 *  |   - `a || not a = top`
 */
var conj = function (dict) {
    return dict.conj;
};

/**
 *  | `(&&)` is an alias for `conj`.
 */
var $amp$amp = function (dictBooleanAlgebra) {
    return conj(dictBooleanAlgebra);
};

/**
 *  | A `Semigroupoid` is similar to a [`Category`](#category) but does not
 *  | require an identity element `id`, just composable morphisms.
 *  |
 *  | `Semigroupoid`s must satisfy the following law:
 *  |
 *  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
 *  |
 *  | One example of a `Semigroupoid` is the function type constructor `(->)`,
 *  | with `(<<<)` defined as function composition.
 */
var compose = function (dict) {
    return dict.compose;
};
var functorFn = new Functor(compose(semigroupoidFn));

/**
 *  | `(<<<)` is an alias for `compose`.
 */
var $less$less$less = function (dictSemigroupoid) {
    return compose(dictSemigroupoid);
};

/**
 *  | Forwards composition, or `(<<<)` with its arguments reversed.
 */
var $greater$greater$greater = function (dictSemigroupoid) {
    return flip(compose(dictSemigroupoid));
};

/**
 *  | The `Ord` type class represents types which support comparisons with a
 *  | _total order_.
 *  |
 *  | `Ord` instances should satisfy the laws of total orderings:
 *  |
 *  | - Reflexivity: `a <= a`
 *  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
 *  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
 */
var compare = function (dict) {
    return dict.compare;
};
var ordArray = function (dictOrd) {
    return new Ord(function () {
        return eqArray(dictOrd["__superclass_Prelude.Eq_0"]());
    }, function (xs) {
        return function (ys) {
            return $dollar(compare(ordInt)(0))($foreign.ordArrayImpl(function (x) {
                return function (y) {
                    var $79 = compare(dictOrd)(x)(y);
                    if ($79 instanceof EQ) {
                        return 0;
                    };
                    if ($79 instanceof LT) {
                        return 1;
                    };
                    if ($79 instanceof GT) {
                        return negate(ringInt)(1);
                    };
                    throw new Error("Failed pattern match at Prelude line 661, column 53 - line 664, column 57: " + [ $79.constructor.name ]);
                };
            })(xs)(ys));
        };
    });
};

/**
 *  | Test whether one value is _strictly less than_ another.
 */
var $less = function (dictOrd) {
    return function (a1) {
        return function (a2) {
            var $80 = compare(dictOrd)(a1)(a2);
            if ($80 instanceof LT) {
                return true;
            };
            return false;
        };
    };
};

/**
 *  | Test whether one value is _non-strictly less than_ another.
 */
var $less$eq = function (dictOrd) {
    return function (a1) {
        return function (a2) {
            var $81 = compare(dictOrd)(a1)(a2);
            if ($81 instanceof GT) {
                return false;
            };
            return true;
        };
    };
};

/**
 *  | Test whether one value is _strictly greater than_ another.
 */
var $greater = function (dictOrd) {
    return function (a1) {
        return function (a2) {
            var $82 = compare(dictOrd)(a1)(a2);
            if ($82 instanceof GT) {
                return true;
            };
            return false;
        };
    };
};

/**
 *  | Test whether one value is _non-strictly greater than_ another.
 */
var $greater$eq = function (dictOrd) {
    return function (a1) {
        return function (a2) {
            var $83 = compare(dictOrd)(a1)(a2);
            if ($83 instanceof LT) {
                return false;
            };
            return true;
        };
    };
};
var categoryFn = new Category(function () {
    return semigroupoidFn;
}, function (x) {
    return x;
});
var boundedUnit = new Bounded(unit, unit);
var boundedOrdering = new Bounded(LT.value, GT.value);
var boundedOrdUnit = new BoundedOrd(function () {
    return boundedUnit;
}, function () {
    return ordUnit;
});
var boundedOrdOrdering = new BoundedOrd(function () {
    return boundedOrdering;
}, function () {
    return ordOrdering;
});
var boundedInt = new Bounded($foreign.bottomInt, $foreign.topInt);
var boundedOrdInt = new BoundedOrd(function () {
    return boundedInt;
}, function () {
    return ordInt;
});

/**
 *  | Characters fall within the Unicode range.
 */
var boundedChar = new Bounded($foreign.bottomChar, $foreign.topChar);
var boundedOrdChar = new BoundedOrd(function () {
    return boundedChar;
}, function () {
    return ordChar;
});
var boundedBoolean = new Bounded(false, true);
var boundedOrdBoolean = new BoundedOrd(function () {
    return boundedBoolean;
}, function () {
    return ordBoolean;
});

/**
 *  | The `Bounded` type class represents types that are finite.
 *  |
 *  | Although there are no "internal" laws for `Bounded`, every value of `a`
 *  | should be considered less than or equal to `top` by some means, and greater
 *  | than or equal to `bottom`.
 *  |
 *  | The lack of explicit `Ord` constraint allows flexibility in the use of
 *  | `Bounded` so it can apply to total and partially ordered sets, boolean
 *  | algebras, etc.
 */
var bottom = function (dict) {
    return dict.bottom;
};
var boundedFn = function (dictBounded) {
    return new Bounded(function (v) {
        return bottom(dictBounded);
    }, function (v) {
        return top(dictBounded);
    });
};
var booleanAlgebraUnit = new BooleanAlgebra(function () {
    return boundedUnit;
}, function (v) {
    return function (v1) {
        return unit;
    };
}, function (v) {
    return function (v1) {
        return unit;
    };
}, function (v) {
    return unit;
});
var booleanAlgebraFn = function (dictBooleanAlgebra) {
    return new BooleanAlgebra(function () {
        return boundedFn(dictBooleanAlgebra["__superclass_Prelude.Bounded_0"]());
    }, function (fx) {
        return function (fy) {
            return function (a) {
                return conj(dictBooleanAlgebra)(fx(a))(fy(a));
            };
        };
    }, function (fx) {
        return function (fy) {
            return function (a) {
                return disj(dictBooleanAlgebra)(fx(a))(fy(a));
            };
        };
    }, function (fx) {
        return function (a) {
            return not(dictBooleanAlgebra)(fx(a));
        };
    });
};
var booleanAlgebraBoolean = new BooleanAlgebra(function () {
    return boundedBoolean;
}, $foreign.boolAnd, $foreign.boolOr, $foreign.boolNot);

/**
 *  | `(/=)` tests whether one value is _not equal_ to another. Shorthand for
 *  | `not (x == y)`.
 */
var $div$eq = function (dictEq) {
    return function (x) {
        return function (y) {
            return not(booleanAlgebraBoolean)($eq$eq(dictEq)(x)(y));
        };
    };
};

/**
 *  | The `Bind` type class extends the [`Apply`](#apply) type class with a
 *  | "bind" operation `(>>=)` which composes computations in sequence, using
 *  | the return value of one computation to determine the next computation.
 *  |
 *  | The `>>=` operator can also be expressed using `do` notation, as follows:
 *  |
 *  | ```purescript
 *  | x >>= f = do y <- x
 *  |              f y
 *  | ```
 *  |
 *  | where the function argument of `f` is given the name `y`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Associativity: `(x >>= f) >>= g = x >>= (\k => f k >>= g)`
 *  |
 *  | Associativity tells us that we can regroup operations which use `do`
 *  | notation so that we can unambiguously write, for example:
 *  |
 *  | ```purescript
 *  | do x <- m1
 *  |    y <- m2 x
 *  |    m3 x y
 *  | ```
 */
var bind = function (dict) {
    return dict.bind;
};

/**
 *  | `liftM1` provides a default implementation of `(<$>)` for any
 *  | [`Monad`](#monad), without using `(<$>)` as provided by the
 *  | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.
 *  |
 *  | `liftM1` can therefore be used to write [`Functor`](#functor) instances
 *  | as follows:
 *  |
 *  | ```purescript
 *  | instance functorF :: Functor F where
 *  |   map = liftM1
 *  | ```
 */
var liftM1 = function (dictMonad) {
    return function (f) {
        return function (a) {
            return bind(dictMonad["__superclass_Prelude.Bind_1"]())(a)(function (v) {
                return $$return(dictMonad["__superclass_Prelude.Applicative_0"]())(f(v));
            });
        };
    };
};

/**
 *  | `(>>=)` is an alias for `bind`.
 */
var $greater$greater$eq = function (dictBind) {
    return bind(dictBind);
};

/**
 *  | This function returns its first argument, and can be used to assert type
 *  | equalities. This can be useful when types are otherwise ambiguous.
 *  |
 *  | ```purescript
 *  | main = print $ [] `asTypeOf` [0]
 *  | ```
 *  |
 *  | If instead, we had written `main = print []`, the type of the argument
 *  | `[]` would have been ambiguous, resulting in a compile-time error.
 */
var asTypeOf = function (x) {
    return function (v) {
        return x;
    };
};
var applyFn = new Apply(function () {
    return functorFn;
}, function (f) {
    return function (g) {
        return function (x) {
            return f(x)(g(x));
        };
    };
});
var bindFn = new Bind(function () {
    return applyFn;
}, function (m) {
    return function (f) {
        return function (x) {
            return f(m(x))(x);
        };
    };
});

/**
 *  | The `Apply` class provides the `(<*>)` which is used to apply a function
 *  | to an argument under a type constructor.
 *  |
 *  | `Apply` can be used to lift functions of two or more arguments to work on
 *  | values wrapped with the type constructor `f`. It might also be understood
 *  | in terms of the `lift2` function:
 *  |
 *  | ```purescript
 *  | lift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c
 *  | lift2 f a b = f <$> a <*> b
 *  | ```
 *  |
 *  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts
 *  | the function application operator `($)` to arguments wrapped with the
 *  | type constructor `f`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Functor`
 *  | laws:
 *  |
 *  | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
 *  |
 *  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 */
var apply = function (dict) {
    return dict.apply;
};

/**
 *  | `(<*>)` is an alias for `apply`.
 */
var $less$times$greater = function (dictApply) {
    return apply(dictApply);
};

/**
 *  | `liftA1` provides a default implementation of `(<$>)` for any
 *  | [`Applicative`](#applicative) functor, without using `(<$>)` as provided
 *  | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass
 *  | relationship.
 *  |
 *  | `liftA1` can therefore be used to write [`Functor`](#functor) instances
 *  | as follows:
 *  |
 *  | ```purescript
 *  | instance functorF :: Functor F where
 *  |   map = liftA1
 *  | ```
 */
var liftA1 = function (dictApplicative) {
    return function (f) {
        return function (a) {
            return $less$times$greater(dictApplicative["__superclass_Prelude.Apply_0"]())(pure(dictApplicative)(f))(a);
        };
    };
};
var applicativeFn = new Applicative(function () {
    return applyFn;
}, $$const);
var monadFn = new Monad(function () {
    return applicativeFn;
}, function () {
    return bindFn;
});

/**
 *  | The `Semigroup` type class identifies an associative operation on a type.
 *  |
 *  | Instances are required to satisfy the following law:
 *  |
 *  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
 *  |
 *  | One example of a `Semigroup` is `String`, with `(<>)` defined as string
 *  | concatenation.
 */
var append = function (dict) {
    return dict.append;
};

/**
 *  | `(++)` is an alternative alias for `append`.
 */
var $plus$plus = function (dictSemigroup) {
    return append(dictSemigroup);
};

/**
 *  | `(<>)` is an alias for `append`.
 */
var $less$greater = function (dictSemigroup) {
    return append(dictSemigroup);
};
var semigroupFn = function (dictSemigroup) {
    return new Semigroup(function (f) {
        return function (g) {
            return function (x) {
                return $less$greater(dictSemigroup)(f(x))(g(x));
            };
        };
    });
};

/**
 *  | `ap` provides a default implementation of `(<*>)` for any
 *  | [`Monad`](#monad), without using `(<*>)` as provided by the
 *  | [`Apply`](#apply)-[`Monad`](#monad) superclass relationship.
 *  |
 *  | `ap` can therefore be used to write [`Apply`](#apply) instances as
 *  | follows:
 *  |
 *  | ```purescript
 *  | instance applyF :: Apply F where
 *  |   apply = ap
 *  | ```
 */
var ap = function (dictMonad) {
    return function (f) {
        return function (a) {
            return bind(dictMonad["__superclass_Prelude.Bind_1"]())(f)(function (v) {
                return bind(dictMonad["__superclass_Prelude.Bind_1"]())(a)(function (v1) {
                    return $$return(dictMonad["__superclass_Prelude.Applicative_0"]())(v(v1));
                });
            });
        };
    };
};
var monadArray = new Monad(function () {
    return applicativeArray;
}, function () {
    return bindArray;
});
var bindArray = new Bind(function () {
    return applyArray;
}, $foreign.arrayBind);
var applyArray = new Apply(function () {
    return functorArray;
}, ap(monadArray));
var applicativeArray = new Applicative(function () {
    return applyArray;
}, function (x) {
    return [ x ];
});

/**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihiliation: `zero * a = a * zero = zero`
 */
var add = function (dict) {
    return dict.add;
};

/**
 *  | `(+)` is an alias for `add`.
 */
var $plus = function (dictSemiring) {
    return add(dictSemiring);
};
module.exports = {
    LT: LT, 
    GT: GT, 
    EQ: EQ, 
    Show: Show, 
    BooleanAlgebra: BooleanAlgebra, 
    BoundedOrd: BoundedOrd, 
    Bounded: Bounded, 
    Ord: Ord, 
    Eq: Eq, 
    DivisionRing: DivisionRing, 
    Num: Num, 
    Ring: Ring, 
    ModuloSemiring: ModuloSemiring, 
    Semiring: Semiring, 
    Semigroup: Semigroup, 
    Monad: Monad, 
    Bind: Bind, 
    Applicative: Applicative, 
    Apply: Apply, 
    Functor: Functor, 
    Category: Category, 
    Semigroupoid: Semigroupoid, 
    show: show, 
    "||": $bar$bar, 
    "&&": $amp$amp, 
    not: not, 
    disj: disj, 
    conj: conj, 
    bottom: bottom, 
    top: top, 
    unsafeCompare: unsafeCompare, 
    ">=": $greater$eq, 
    "<=": $less$eq, 
    ">": $greater, 
    "<": $less, 
    compare: compare, 
    "/=": $div$eq, 
    "==": $eq$eq, 
    eq: eq, 
    "-": $minus, 
    negate: negate, 
    sub: sub, 
    "/": $div, 
    mod: mod, 
    div: div, 
    "*": $times, 
    "+": $plus, 
    one: one, 
    mul: mul, 
    zero: zero, 
    add: add, 
    "++": $plus$plus, 
    "<>": $less$greater, 
    append: append, 
    ap: ap, 
    liftM1: liftM1, 
    "return": $$return, 
    ">>=": $greater$greater$eq, 
    bind: bind, 
    liftA1: liftA1, 
    pure: pure, 
    "<*>": $less$times$greater, 
    apply: apply, 
    "void": $$void, 
    "<#>": $less$hash$greater, 
    "<$>": $less$dollar$greater, 
    map: map, 
    id: id, 
    ">>>": $greater$greater$greater, 
    "<<<": $less$less$less, 
    compose: compose, 
    otherwise: otherwise, 
    asTypeOf: asTypeOf, 
    "const": $$const, 
    flip: flip, 
    "#": $hash, 
    "$": $dollar, 
    unit: unit, 
    semigroupoidFn: semigroupoidFn, 
    categoryFn: categoryFn, 
    functorFn: functorFn, 
    functorArray: functorArray, 
    applyFn: applyFn, 
    applyArray: applyArray, 
    applicativeFn: applicativeFn, 
    applicativeArray: applicativeArray, 
    bindFn: bindFn, 
    bindArray: bindArray, 
    monadFn: monadFn, 
    monadArray: monadArray, 
    semigroupString: semigroupString, 
    semigroupUnit: semigroupUnit, 
    semigroupFn: semigroupFn, 
    semigroupOrdering: semigroupOrdering, 
    semigroupArray: semigroupArray, 
    semiringInt: semiringInt, 
    semiringNumber: semiringNumber, 
    semiringUnit: semiringUnit, 
    ringInt: ringInt, 
    ringNumber: ringNumber, 
    ringUnit: ringUnit, 
    moduloSemiringInt: moduloSemiringInt, 
    moduloSemiringNumber: moduloSemiringNumber, 
    moduloSemiringUnit: moduloSemiringUnit, 
    divisionRingNumber: divisionRingNumber, 
    divisionRingUnit: divisionRingUnit, 
    numNumber: numNumber, 
    numUnit: numUnit, 
    eqBoolean: eqBoolean, 
    eqInt: eqInt, 
    eqNumber: eqNumber, 
    eqChar: eqChar, 
    eqString: eqString, 
    eqUnit: eqUnit, 
    eqArray: eqArray, 
    eqOrdering: eqOrdering, 
    ordBoolean: ordBoolean, 
    ordInt: ordInt, 
    ordNumber: ordNumber, 
    ordString: ordString, 
    ordChar: ordChar, 
    ordUnit: ordUnit, 
    ordArray: ordArray, 
    ordOrdering: ordOrdering, 
    boundedBoolean: boundedBoolean, 
    boundedUnit: boundedUnit, 
    boundedOrdering: boundedOrdering, 
    boundedInt: boundedInt, 
    boundedChar: boundedChar, 
    boundedFn: boundedFn, 
    boundedOrdBoolean: boundedOrdBoolean, 
    boundedOrdUnit: boundedOrdUnit, 
    boundedOrdOrdering: boundedOrdOrdering, 
    boundedOrdInt: boundedOrdInt, 
    boundedOrdChar: boundedOrdChar, 
    booleanAlgebraBoolean: booleanAlgebraBoolean, 
    booleanAlgebraUnit: booleanAlgebraUnit, 
    booleanAlgebraFn: booleanAlgebraFn, 
    showBoolean: showBoolean, 
    showInt: showInt, 
    showNumber: showNumber, 
    showChar: showChar, 
    showString: showString, 
    showUnit: showUnit, 
    showArray: showArray, 
    showOrdering: showOrdering
};
