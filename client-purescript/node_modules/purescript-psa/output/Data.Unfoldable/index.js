// Generated by psc version 0.8.5.0

/**
 *  | This module provides a type class for _unfoldable functors_, i.e.
 *  | functors which support an `unfoldr` operation.
 *  |
 *  | This allows us to unify various operations on arrays, lists,
 *  | sequences, etc.
 */
"use strict";
var Prelude = require("../Prelude");
var Data_Maybe = require("../Data.Maybe");
var Data_Tuple = require("../Data.Tuple");
var Data_Array_ST = require("../Data.Array.ST");
var Data_Traversable = require("../Data.Traversable");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_ST = require("../Control.Monad.ST");

/**
 *  | This class identifies data structures which can be _unfolded_,
 *  | generalizing `unfoldr` on arrays.
 *  |
 *  | The generating function `f` in `unfoldr f` in understood as follows:
 *  |
 *  | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.
 *  | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`
 *  |   appended to the result of `unfoldr f b1`.
 */
var Unfoldable = function (unfoldr) {
    this.unfoldr = unfoldr;
};

/**
 *  | This class identifies data structures which can be _unfolded_,
 *  | generalizing `unfoldr` on arrays.
 *  |
 *  | The generating function `f` in `unfoldr f` in understood as follows:
 *  |
 *  | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.
 *  | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`
 *  |   appended to the result of `unfoldr f b1`.
 */
var unfoldr = function (dict) {
    return dict.unfoldr;
};
var unfoldableArray = new Unfoldable(function (f) {
    return function (b) {
        return Control_Monad_Eff.runPure(Data_Array_ST.runSTArray(function __do() {
            var v = Data_Array_ST.emptySTArray();
            var v1 = Control_Monad_ST.newSTRef(b)();
            (function () {
                while (!(function __do() {
                    var v2 = Control_Monad_ST.readSTRef(v1)();
                    var $12 = f(v2);
                    if ($12 instanceof Data_Maybe.Nothing) {
                        return true;
                    };
                    if ($12 instanceof Data_Maybe.Just) {
                        Data_Array_ST.pushSTArray(v)($12.value0.value0)();
                        Control_Monad_ST.writeSTRef(v1)($12.value0.value1)();
                        return false;
                    };
                    throw new Error("Failed pattern match at Data.Unfoldable line 35, column 7 - line 41, column 5: " + [ $12.constructor.name ]);
                })()) {

                };
                return {};
            })();
            return v;
        }));
    };
});

/**
 *  | Replicate a value some natural number of times.
 *  | For example:
 *  |
 *  | ~~~ purescript
 *  | replicate 2 "foo" == ["foo", "foo"] :: Array String
 *  | ~~~
 */
var replicate = function (dictUnfoldable) {
    return function (n) {
        return function (v) {
            var step = function (i) {
                var $16 = i <= 0;
                if ($16) {
                    return Data_Maybe.Nothing.value;
                };
                if (!$16) {
                    return new Data_Maybe.Just(new Data_Tuple.Tuple(v, i - 1));
                };
                throw new Error("Failed pattern match at Data.Unfoldable line 54, column 7 - line 58, column 1: " + [ $16.constructor.name ]);
            };
            return unfoldr(dictUnfoldable)(step)(n);
        };
    };
};

/**
 *  | Perform an Applicative action `n` times, and accumulate all the results.
 */
var replicateA = function (dictApplicative) {
    return function (dictUnfoldable) {
        return function (dictTraversable) {
            return function (n) {
                return function (m) {
                    return Data_Traversable.sequence(dictTraversable)(dictApplicative)(replicate(dictUnfoldable)(n)(m));
                };
            };
        };
    };
};

/**
 *  | Contain a single value.
 *  | For example:
 *  |
 *  | ~~~ purescript
 *  | singleton "foo" == ["foo"] :: Array String
 *  | ~~~
 */
var singleton = function (dictUnfoldable) {
    return replicate(dictUnfoldable)(1);
};

/**
 *  | The container with no elements - unfolded with zero iterations.
 *  | For example:
 *  |
 *  | ~~~ purescript
 *  | none == [] :: forall a. Array a
 *  | ~~~
 */
var none = function (dictUnfoldable) {
    return unfoldr(dictUnfoldable)(Prelude["const"](Data_Maybe.Nothing.value))(Prelude.unit);
};
module.exports = {
    Unfoldable: Unfoldable, 
    singleton: singleton, 
    none: none, 
    replicateA: replicateA, 
    replicate: replicate, 
    unfoldr: unfoldr, 
    unfoldableArray: unfoldableArray
};
