// Generated by psc version 0.8.5.0
"use strict";
var $foreign = require("./foreign");
var Prelude = require("../Prelude");
var Control_Apply = require("../Control.Apply");
var Data_Maybe = require("../Data.Maybe");
var Data_Maybe_First = require("../Data.Maybe.First");
var Data_Maybe_Last = require("../Data.Maybe.Last");
var Data_Monoid = require("../Data.Monoid");
var Data_Monoid_Additive = require("../Data.Monoid.Additive");
var Data_Monoid_Conj = require("../Data.Monoid.Conj");
var Data_Monoid_Disj = require("../Data.Monoid.Disj");
var Data_Monoid_Dual = require("../Data.Monoid.Dual");
var Data_Monoid_Endo = require("../Data.Monoid.Endo");
var Data_Monoid_Multiplicative = require("../Data.Monoid.Multiplicative");

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */
var Foldable = function (foldMap, foldl, foldr) {
    this.foldMap = foldMap;
    this.foldl = foldl;
    this.foldr = foldr;
};

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */
var foldr = function (dict) {
    return dict.foldr;
};

/**
 *  | Traverse a data structure, performing some effects encoded by an
 *  | `Applicative` functor at each value, ignoring the final result.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | traverse_ print [1, 2, 3]
 *  | ```
 */
var traverse_ = function (dictApplicative) {
    return function (dictFoldable) {
        return function (f) {
            return foldr(dictFoldable)(function ($161) {
                return Control_Apply["*>"](dictApplicative["__superclass_Prelude.Apply_0"]())(f($161));
            })(Prelude.pure(dictApplicative)(Prelude.unit));
        };
    };
};

/**
 *  | A version of `traverse_` with its arguments flipped.
 *  |
 *  | This can be useful when running an action written using do notation
 *  | for every element in a data structure:
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | for_ [1, 2, 3] \n -> do
 *  |   print n
 *  |   trace "squared is"
 *  |   print (n * n)
 *  | ```
 */
var for_ = function (dictApplicative) {
    return function (dictFoldable) {
        return Prelude.flip(traverse_(dictApplicative)(dictFoldable));
    };
};

/**
 *  | Perform all of the effects in some data structure in the order
 *  | given by the `Foldable` instance, ignoring the final result.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | sequence_ [ trace "Hello, ", trace " world!" ]
 *  | ```
 */
var sequence_ = function (dictApplicative) {
    return function (dictFoldable) {
        return traverse_(dictApplicative)(dictFoldable)(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */
var foldl = function (dict) {
    return dict.foldl;
};

/**
 *  | Fold a data structure, accumulating values in some `Monoid`,
 *  | combining adjacent elements using the specified separator.
 */
var intercalate = function (dictFoldable) {
    return function (dictMonoid) {
        return function (sep) {
            return function (xs) {
                var go = function (v) {
                    return function (x) {
                        if (v.init) {
                            return {
                                init: false, 
                                acc: x
                            };
                        };
                        return {
                            init: false, 
                            acc: Prelude["<>"](dictMonoid["__superclass_Prelude.Semigroup_0"]())(v.acc)(Prelude["<>"](dictMonoid["__superclass_Prelude.Semigroup_0"]())(sep)(x))
                        };
                    };
                };
                return (foldl(dictFoldable)(go)({
                    init: true, 
                    acc: Data_Monoid.mempty(dictMonoid)
                })(xs)).acc;
            };
        };
    };
};

/**
 *  | Find the largest element of a structure, according to a given comparison
 *  | function. The comparison function should represent a total ordering (see
 *  | the `Ord` type class laws); if it does not, the behaviour is undefined.
 */
var maximumBy = function (dictFoldable) {
    return function (cmp) {
        var max$prime = function (v) {
            return function (v1) {
                if (v instanceof Data_Maybe.Nothing) {
                    return new Data_Maybe.Just(v1);
                };
                if (v instanceof Data_Maybe.Just) {
                    return new Data_Maybe.Just((function () {
                        var $87 = cmp(v.value0)(v1);
                        if ($87 instanceof Prelude.GT) {
                            return v.value0;
                        };
                        return v1;
                    })());
                };
                throw new Error("Failed pattern match at Data.Foldable line 246, column 3 - line 247, column 3: " + [ v.constructor.name, v1.constructor.name ]);
            };
        };
        return foldl(dictFoldable)(max$prime)(Data_Maybe.Nothing.value);
    };
};

/**
 *  | Find the largest element of a structure, according to its `Ord` instance.
 */
var maximum = function (dictOrd) {
    return function (dictFoldable) {
        return maximumBy(dictFoldable)(Prelude.compare(dictOrd));
    };
};

/**
 *  | Fold a data structure, accumulating values in some `Monoid`.
 */
var mconcat = function (dictFoldable) {
    return function (dictMonoid) {
        return foldl(dictFoldable)(Prelude["<>"](dictMonoid["__superclass_Prelude.Semigroup_0"]()))(Data_Monoid.mempty(dictMonoid));
    };
};

/**
 *  | Find the smallest element of a structure, according to a given comparison
 *  | function. The comparison function should represent a total ordering (see
 *  | the `Ord` type class laws); if it does not, the behaviour is undefined.
 */
var minimumBy = function (dictFoldable) {
    return function (cmp) {
        var min$prime = function (v) {
            return function (v1) {
                if (v instanceof Data_Maybe.Nothing) {
                    return new Data_Maybe.Just(v1);
                };
                if (v instanceof Data_Maybe.Just) {
                    return new Data_Maybe.Just((function () {
                        var $91 = cmp(v.value0)(v1);
                        if ($91 instanceof Prelude.LT) {
                            return v.value0;
                        };
                        return v1;
                    })());
                };
                throw new Error("Failed pattern match at Data.Foldable line 261, column 3 - line 262, column 3: " + [ v.constructor.name, v1.constructor.name ]);
            };
        };
        return foldl(dictFoldable)(min$prime)(Data_Maybe.Nothing.value);
    };
};

/**
 *  | Find the smallest element of a structure, according to its `Ord` instance.
 */
var minimum = function (dictOrd) {
    return function (dictFoldable) {
        return minimumBy(dictFoldable)(Prelude.compare(dictOrd));
    };
};

/**
 *  | Find the product of the numeric values in a data structure.
 */
var product = function (dictFoldable) {
    return function (dictSemiring) {
        return foldl(dictFoldable)(Prelude["*"](dictSemiring))(Prelude.one(dictSemiring));
    };
};

/**
 *  | Find the sum of the numeric values in a data structure.
 */
var sum = function (dictFoldable) {
    return function (dictSemiring) {
        return foldl(dictFoldable)(Prelude["+"](dictSemiring))(Prelude.zero(dictSemiring));
    };
};
var foldableMultiplicative = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return f(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(v)(z);
        };
    };
});
var foldableMaybe = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            if (v instanceof Data_Maybe.Nothing) {
                return Data_Monoid.mempty(dictMonoid);
            };
            if (v instanceof Data_Maybe.Just) {
                return f(v.value0);
            };
            throw new Error("Failed pattern match at Data.Foldable line 108, column 3 - line 109, column 3: " + [ f.constructor.name, v.constructor.name ]);
        };
    };
}, function (v) {
    return function (z) {
        return function (v1) {
            if (v1 instanceof Data_Maybe.Nothing) {
                return z;
            };
            if (v1 instanceof Data_Maybe.Just) {
                return v(z)(v1.value0);
            };
            throw new Error("Failed pattern match at Data.Foldable line 106, column 3 - line 107, column 3: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
        };
    };
}, function (v) {
    return function (z) {
        return function (v1) {
            if (v1 instanceof Data_Maybe.Nothing) {
                return z;
            };
            if (v1 instanceof Data_Maybe.Just) {
                return v(v1.value0)(z);
            };
            throw new Error("Failed pattern match at Data.Foldable line 104, column 3 - line 105, column 3: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
        };
    };
});
var foldableDual = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return f(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(v)(z);
        };
    };
});
var foldableDisj = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return f(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(v)(z);
        };
    };
});
var foldableConj = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return f(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(v)(z);
        };
    };
});
var foldableAdditive = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return f(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return f(v)(z);
        };
    };
});

/**
 *  | A default implementation of `foldMap` using `foldr`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldrDefault`.
 */
var foldMapDefaultR = function (dictFoldable) {
    return function (dictMonoid) {
        return function (f) {
            return function (xs) {
                return foldr(dictFoldable)(function (x) {
                    return function (acc) {
                        return Prelude["<>"](dictMonoid["__superclass_Prelude.Semigroup_0"]())(f(x))(acc);
                    };
                })(Data_Monoid.mempty(dictMonoid))(xs);
            };
        };
    };
};
var foldableArray = new Foldable(function (dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
}, $foreign.foldlArray, $foreign.foldrArray);

/**
 *  | A default implementation of `foldMap` using `foldl`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldlDefault`.
 */
var foldMapDefaultL = function (dictFoldable) {
    return function (dictMonoid) {
        return function (f) {
            return function (xs) {
                return foldl(dictFoldable)(function (acc) {
                    return function (x) {
                        return Prelude["<>"](dictMonoid["__superclass_Prelude.Semigroup_0"]())(f(x))(acc);
                    };
                })(Data_Monoid.mempty(dictMonoid))(xs);
            };
        };
    };
};

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */
var foldMap = function (dict) {
    return dict.foldMap;
};
var foldableFirst = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return foldMap(foldableMaybe)(dictMonoid)(f)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return foldl(foldableMaybe)(f)(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return foldr(foldableMaybe)(f)(z)(v);
        };
    };
});
var foldableLast = new Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            return foldMap(foldableMaybe)(dictMonoid)(f)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return foldl(foldableMaybe)(f)(z)(v);
        };
    };
}, function (f) {
    return function (z) {
        return function (v) {
            return foldr(foldableMaybe)(f)(z)(v);
        };
    };
});

/**
 *  | A default implementation of `foldl` using `foldMap`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldMapDefaultL`.
 */
var foldlDefault = function (dictFoldable) {
    return function (c) {
        return function (u) {
            return function (xs) {
                return Data_Monoid_Endo.runEndo(Data_Monoid_Dual.runDual(foldMap(dictFoldable)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo))(function ($162) {
                    return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Prelude.flip(c)($162)));
                })(xs)))(u);
            };
        };
    };
};

/**
 *  | A default implementation of `foldr` using `foldMap`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldMapDefaultR`.
 */
var foldrDefault = function (dictFoldable) {
    return function (c) {
        return function (u) {
            return function (xs) {
                return Data_Monoid_Endo.runEndo(foldMap(dictFoldable)(Data_Monoid_Endo.monoidEndo)(function ($163) {
                    return Data_Monoid_Endo.Endo(c($163));
                })(xs))(u);
            };
        };
    };
};

/**
 *  | Fold a data structure, accumulating values in some `Monoid`.
 */
var fold = function (dictFoldable) {
    return function (dictMonoid) {
        return foldMap(dictFoldable)(dictMonoid)(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | Try to find an element in a data structure which satisfies a predicate.
 */
var find = function (dictFoldable) {
    return function (p) {
        return foldl(dictFoldable)(function (r) {
            return function (x) {
                var $160 = p(x);
                if ($160) {
                    return new Data_Maybe.Just(x);
                };
                if (!$160) {
                    return r;
                };
                throw new Error("Failed pattern match at Data.Foldable line 234, column 25 - line 234, column 50: " + [ $160.constructor.name ]);
            };
        })(Data_Maybe.Nothing.value);
    };
};

/**
 *  | Test whether a predicate holds for any element in a data structure.
 */
var any = function (dictFoldable) {
    return function (dictBooleanAlgebra) {
        return function (p) {
            return function ($164) {
                return Data_Monoid_Disj.runDisj(foldMap(dictFoldable)(Data_Monoid_Disj.monoidDisj(dictBooleanAlgebra))(function ($165) {
                    return Data_Monoid_Disj.Disj(p($165));
                })($164));
            };
        };
    };
};

/**
 *  | Test whether a value is an element of a data structure.
 */
var elem = function (dictFoldable) {
    return function (dictEq) {
        return function ($166) {
            return any(dictFoldable)(Prelude.booleanAlgebraBoolean)(Prelude["=="](dictEq)($166));
        };
    };
};

/**
 *  | Test whether a value is not an element of a data structure.
 */
var notElem = function (dictFoldable) {
    return function (dictEq) {
        return function (x) {
            return function ($167) {
                return !elem(dictFoldable)(dictEq)(x)($167);
            };
        };
    };
};

/**
 *  | Test whether any `Boolean` value in a data structure is `true`.
 */
var or = function (dictFoldable) {
    return function (dictBooleanAlgebra) {
        return any(dictFoldable)(dictBooleanAlgebra)(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | Test whether a predicate holds for all elements in a data structure.
 */
var all = function (dictFoldable) {
    return function (dictBooleanAlgebra) {
        return function (p) {
            return function ($168) {
                return Data_Monoid_Conj.runConj(foldMap(dictFoldable)(Data_Monoid_Conj.monoidConj(dictBooleanAlgebra))(function ($169) {
                    return Data_Monoid_Conj.Conj(p($169));
                })($168));
            };
        };
    };
};

/**
 *  | Test whether all `Boolean` values in a data structure are `true`.
 */
var and = function (dictFoldable) {
    return function (dictBooleanAlgebra) {
        return all(dictFoldable)(dictBooleanAlgebra)(Prelude.id(Prelude.categoryFn));
    };
};
module.exports = {
    Foldable: Foldable, 
    minimumBy: minimumBy, 
    minimum: minimum, 
    maximumBy: maximumBy, 
    maximum: maximum, 
    find: find, 
    notElem: notElem, 
    elem: elem, 
    product: product, 
    sum: sum, 
    all: all, 
    any: any, 
    or: or, 
    and: and, 
    intercalate: intercalate, 
    mconcat: mconcat, 
    sequence_: sequence_, 
    for_: for_, 
    traverse_: traverse_, 
    fold: fold, 
    foldMapDefaultR: foldMapDefaultR, 
    foldMapDefaultL: foldMapDefaultL, 
    foldlDefault: foldlDefault, 
    foldrDefault: foldrDefault, 
    foldMap: foldMap, 
    foldl: foldl, 
    foldr: foldr, 
    foldableArray: foldableArray, 
    foldableMaybe: foldableMaybe, 
    foldableFirst: foldableFirst, 
    foldableLast: foldableLast, 
    foldableAdditive: foldableAdditive, 
    foldableDual: foldableDual, 
    foldableDisj: foldableDisj, 
    foldableConj: foldableConj, 
    foldableMultiplicative: foldableMultiplicative
};
