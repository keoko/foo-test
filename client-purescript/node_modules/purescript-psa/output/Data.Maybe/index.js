// Generated by psc version 0.8.5.0
"use strict";
var Prelude = require("../Prelude");
var Control_Alt = require("../Control.Alt");
var Control_Alternative = require("../Control.Alternative");
var Control_Extend = require("../Control.Extend");
var Control_MonadPlus = require("../Control.MonadPlus");
var Control_Plus = require("../Control.Plus");
var Data_Functor_Invariant = require("../Data.Functor.Invariant");
var Data_Monoid = require("../Data.Monoid");

/**
 *  | The `Maybe` type is used to represent optional values and can be seen as
 *  | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
 *  | is the non-null value `x`.
 */
var Nothing = (function () {
    function Nothing() {

    };
    Nothing.value = new Nothing();
    return Nothing;
})();

/**
 *  | The `Maybe` type is used to represent optional values and can be seen as
 *  | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
 *  | is the non-null value `x`.
 */
var Just = (function () {
    function Just(value0) {
        this.value0 = value0;
    };
    Just.create = function (value0) {
        return new Just(value0);
    };
    return Just;
})();

/**
 *  | The `Show` instance allows `Maybe` values to be rendered as a string with
 *  | `show` whenever there is an `Show` instance for the type the `Maybe`
 *  | contains.
 */
var showMaybe = function (dictShow) {
    return new Prelude.Show(function (v) {
        if (v instanceof Just) {
            return "Just (" + (Prelude.show(dictShow)(v.value0) + ")");
        };
        if (v instanceof Nothing) {
            return "Nothing";
        };
        throw new Error("Failed pattern match at Data.Maybe line 290, column 3 - line 291, column 3: " + [ v.constructor.name ]);
    });
};

/**
 *  | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values
 *  | whenever there is a `Semigroup` instance for the type the `Maybe` contains.
 *  | The exact behaviour of `<>` depends on the "inner" `Semigroup` instance,
 *  | but generally captures the notion of appending or combining things.
 *  |
 *  | ``` purescript
 *  | Just x <> Just y = Just (x <> y)
 *  | Just x <> Nothing = Just x
 *  | Nothing <> Just y = Just y
 *  | Nothing <> Nothing = Nothing
 *  | ```
 */
var semigroupMaybe = function (dictSemigroup) {
    return new Prelude.Semigroup(function (v) {
        return function (v1) {
            if (v instanceof Nothing) {
                return v1;
            };
            if (v1 instanceof Nothing) {
                return v;
            };
            if (v instanceof Just && v1 instanceof Just) {
                return new Just(Prelude["<>"](dictSemigroup)(v.value0)(v1.value0));
            };
            throw new Error("Failed pattern match at Data.Maybe line 232, column 3 - line 233, column 3: " + [ v.constructor.name, v1.constructor.name ]);
        };
    });
};
var monoidMaybe = function (dictSemigroup) {
    return new Data_Monoid.Monoid(function () {
        return semigroupMaybe(dictSemigroup);
    }, Nothing.value);
};

/**
 *  | Similar to `maybe` but for use in cases where the default value may be
 *  | expensive to compute. As PureScript is not lazy, the standard `maybe` has
 *  | to evaluate the default value before returning the result, whereas here
 *  | the value is only computed when the `Maybe` is known to be `Nothing`.
 *  |
 *  | ``` purescript
 *  | maybe' (\_ -> x) f Nothing == x
 *  | maybe' (\_ -> x) f (Just y) == f y
 *  | ```
 */
var maybe$prime = function (v) {
    return function (v1) {
        return function (v2) {
            if (v2 instanceof Nothing) {
                return v(Prelude.unit);
            };
            if (v2 instanceof Just) {
                return v1(v2.value0);
            };
            throw new Error("Failed pattern match at Data.Maybe line 40, column 1 - line 41, column 1: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
        };
    };
};

/**
 *  | Takes a default value, a function, and a `Maybe` value. If the `Maybe`
 *  | value is `Nothing` the default value is returned, otherwise the function
 *  | is applied to the value inside the `Just` and the result is returned.
 *  |
 *  | ``` purescript
 *  | maybe x f Nothing == x
 *  | maybe x f (Just y) == f y
 *  | ```
 */
var maybe = function (v) {
    return function (v1) {
        return function (v2) {
            if (v2 instanceof Nothing) {
                return v;
            };
            if (v2 instanceof Just) {
                return v1(v2.value0);
            };
            throw new Error("Failed pattern match at Data.Maybe line 27, column 1 - line 28, column 1: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
        };
    };
};

/**
 *  | Returns `true` when the `Maybe` value is `Nothing`.
 */
var isNothing = maybe(true)(Prelude["const"](false));

/**
 *  | Returns `true` when the `Maybe` value was constructed with `Just`.
 */
var isJust = maybe(false)(Prelude["const"](true));

/**
 *  | The `Functor` instance allows functions to transform the contents of a
 *  | `Just` with the `<$>` operator:
 *  |
 *  | ``` purescript
 *  | f <$> Just x == Just (f x)
 *  | ```
 *  |
 *  | `Nothing` values are left untouched:
 *  |
 *  | ``` purescript
 *  | f <$> Nothing == Nothing
 *  | ```
 */
var functorMaybe = new Prelude.Functor(function (v) {
    return function (v1) {
        if (v1 instanceof Just) {
            return new Just(v(v1.value0));
        };
        return Nothing.value;
    };
});
var invariantMaybe = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorMaybe));

/**
 *  | Similar to `fromMaybe` but for use in cases where the default value may be
 *  | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`
 *  | has to evaluate the default value before returning the result, whereas here
 *  | the value is only computed when the `Maybe` is known to be `Nothing`.
 *  |
 *  | ``` purescript
 *  | fromMaybe' (\_ -> x) Nothing == x
 *  | fromMaybe' (\_ -> x) (Just y) == y
 *  | ```
 */
var fromMaybe$prime = function (a) {
    return maybe$prime(a)(Prelude.id(Prelude.categoryFn));
};

/**
 *  | Takes a default value, and a `Maybe` value. If the `Maybe` value is
 *  | `Nothing` the default value is returned, otherwise the value inside the
 *  | `Just` is returned.
 *  |
 *  | ``` purescript
 *  | fromMaybe x Nothing == x
 *  | fromMaybe x (Just y) == y
 *  | ```
 */
var fromMaybe = function (a) {
    return maybe(a)(Prelude.id(Prelude.categoryFn));
};

/**
 *  | The `Extend` instance allows sequencing of `Maybe` values and functions
 *  | that accept a `Maybe a` and return a non-`Maybe` result using the
 *  | `<<=` operator.
 *  |
 *  | ``` purescript
 *  | f <<= Nothing = Nothing
 *  | f <<= Just x = Just (f x)
 *  | ```
 */
var extendMaybe = new Control_Extend.Extend(function () {
    return functorMaybe;
}, function (v) {
    return function (v1) {
        if (v1 instanceof Nothing) {
            return Nothing.value;
        };
        return new Just(v(v1));
    };
});

/**
 *  | The `Eq` instance allows `Maybe` values to be checked for equality with
 *  | `==` and inequality with `/=` whenever there is an `Eq` instance for the
 *  | type the `Maybe` contains.
 */
var eqMaybe = function (dictEq) {
    return new Prelude.Eq(function (v) {
        return function (v1) {
            if (v instanceof Nothing && v1 instanceof Nothing) {
                return true;
            };
            if (v instanceof Just && v1 instanceof Just) {
                return Prelude["=="](dictEq)(v.value0)(v1.value0);
            };
            return false;
        };
    });
};

/**
 *  | The `Ord` instance allows `Maybe` values to be compared with
 *  | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for
 *  | the type the `Maybe` contains.
 *  |
 *  | `Nothing` is considered to be less than any `Just` value.
 */
var ordMaybe = function (dictOrd) {
    return new Prelude.Ord(function () {
        return eqMaybe(dictOrd["__superclass_Prelude.Eq_0"]());
    }, function (v) {
        return function (v1) {
            if (v instanceof Just && v1 instanceof Just) {
                return Prelude.compare(dictOrd)(v.value0)(v1.value0);
            };
            if (v instanceof Nothing && v1 instanceof Nothing) {
                return Prelude.EQ.value;
            };
            if (v instanceof Nothing) {
                return Prelude.LT.value;
            };
            if (v1 instanceof Nothing) {
                return Prelude.GT.value;
            };
            throw new Error("Failed pattern match at Data.Maybe line 270, column 3 - line 271, column 3: " + [ v.constructor.name, v1.constructor.name ]);
        };
    });
};
var boundedMaybe = function (dictBounded) {
    return new Prelude.Bounded(Nothing.value, new Just(Prelude.top(dictBounded)));
};
var boundedOrdMaybe = function (dictBoundedOrd) {
    return new Prelude.BoundedOrd(function () {
        return boundedMaybe(dictBoundedOrd["__superclass_Prelude.Bounded_0"]());
    }, function () {
        return ordMaybe(dictBoundedOrd["__superclass_Prelude.Ord_1"]());
    });
};

/**
 *  | The `Apply` instance allows functions contained within a `Just` to
 *  | transform a value contained within a `Just` using the `apply` operator:
 *  |
 *  | ``` purescript
 *  | Just f <*> Just x == Just (f x)
 *  | ```
 *  |
 *  | `Nothing` values are left untouched:
 *  |
 *  | ``` purescript
 *  | Just f <*> Nothing == Nothing
 *  | Nothing <*> Just x == Nothing
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a
 *  | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`
 *  | becomes `f :: Maybe a -> Maybe b -> Maybe c`:
 *  |
 *  | ``` purescript
 *  | f <$> Just x <*> Just y == Just (f x y)
 *  | ```
 *  |
 *  | The `Nothing`-preserving behaviour of both operators means the result of
 *  | an expression like the above but where any one of the values is `Nothing`
 *  | means the whole result becomes `Nothing` also:
 *  |
 *  | ``` purescript
 *  | f <$> Nothing <*> Just y == Nothing
 *  | f <$> Just x <*> Nothing == Nothing
 *  | f <$> Nothing <*> Nothing == Nothing
 *  | ```
 */
var applyMaybe = new Prelude.Apply(function () {
    return functorMaybe;
}, function (v) {
    return function (v1) {
        if (v instanceof Just) {
            return Prelude["<$>"](functorMaybe)(v.value0)(v1);
        };
        if (v instanceof Nothing) {
            return Nothing.value;
        };
        throw new Error("Failed pattern match at Data.Maybe line 122, column 3 - line 123, column 3: " + [ v.constructor.name, v1.constructor.name ]);
    };
});

/**
 *  | The `Bind` instance allows sequencing of `Maybe` values and functions that
 *  | return a `Maybe` by using the `>>=` operator:
 *  |
 *  | ``` purescript
 *  | Just x >>= f = f x
 *  | Nothing >>= f = Nothing
 *  | ```
 */
var bindMaybe = new Prelude.Bind(function () {
    return applyMaybe;
}, function (v) {
    return function (v1) {
        if (v instanceof Just) {
            return v1(v.value0);
        };
        if (v instanceof Nothing) {
            return Nothing.value;
        };
        throw new Error("Failed pattern match at Data.Maybe line 181, column 3 - line 182, column 3: " + [ v.constructor.name, v1.constructor.name ]);
    };
});
var booleanAlgebraMaybe = function (dictBooleanAlgebra) {
    return new Prelude.BooleanAlgebra(function () {
        return boundedMaybe(dictBooleanAlgebra["__superclass_Prelude.Bounded_0"]());
    }, function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.conj(dictBooleanAlgebra))(x))(y);
        };
    }, function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.disj(dictBooleanAlgebra))(x))(y);
        };
    }, Prelude.map(functorMaybe)(Prelude.not(dictBooleanAlgebra)));
};
var semiringMaybe = function (dictSemiring) {
    return new Prelude.Semiring(function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.add(dictSemiring))(x))(y);
        };
    }, function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.mul(dictSemiring))(x))(y);
        };
    }, new Just(Prelude.one(dictSemiring)), new Just(Prelude.zero(dictSemiring)));
};
var moduloSemiringMaybe = function (dictModuloSemiring) {
    return new Prelude.ModuloSemiring(function () {
        return semiringMaybe(dictModuloSemiring["__superclass_Prelude.Semiring_0"]());
    }, function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.div(dictModuloSemiring))(x))(y);
        };
    }, function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.mod(dictModuloSemiring))(x))(y);
        };
    });
};
var ringMaybe = function (dictRing) {
    return new Prelude.Ring(function () {
        return semiringMaybe(dictRing["__superclass_Prelude.Semiring_0"]());
    }, function (x) {
        return function (y) {
            return Prelude["<*>"](applyMaybe)(Prelude["<$>"](functorMaybe)(Prelude.sub(dictRing))(x))(y);
        };
    });
};
var divisionRingMaybe = function (dictDivisionRing) {
    return new Prelude.DivisionRing(function () {
        return moduloSemiringMaybe(dictDivisionRing["__superclass_Prelude.ModuloSemiring_1"]());
    }, function () {
        return ringMaybe(dictDivisionRing["__superclass_Prelude.Ring_0"]());
    });
};
var numMaybe = function (dictNum) {
    return new Prelude.Num(function () {
        return divisionRingMaybe(dictNum["__superclass_Prelude.DivisionRing_0"]());
    });
};

/**
 *  | The `Applicative` instance enables lifting of values into `Maybe` with the
 *  | `pure` or `return` function (`return` is an alias for `pure`):
 *  |
 *  | ``` purescript
 *  | pure x :: Maybe _ == Just x
 *  | return x :: Maybe _ == Just x
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s
 *  | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed
 *  | values to a function that does not usually expect them, by using `pure`
 *  | for any value that is not already `Maybe` typed:
 *  |
 *  | ``` purescript
 *  | f <$> Just x <*> pure y == Just (f x y)
 *  | ```
 *  |
 *  | Even though `pure = Just` it is recommended to use `pure` in situations
 *  | like this as it allows the choice of `Applicative` to be changed later
 *  | without having to go through and replace `Just` with a new constructor.
 */
var applicativeMaybe = new Prelude.Applicative(function () {
    return applyMaybe;
}, Just.create);

/**
 *  | The `Monad` instance guarantees that there are both `Applicative` and
 *  | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:
 *  |
 *  | ``` purescript
 *  | do
 *  |   x' <- x
 *  |   y' <- y
 *  |   pure (f x' y')
 *  | ```
 *  |
 *  | Which is equivalent to:
 *  |
 *  | ``` purescript
 *  | x >>= (\x' -> y >>= (\y' -> pure (f x' y')))
 *  | ```
 */
var monadMaybe = new Prelude.Monad(function () {
    return applicativeMaybe;
}, function () {
    return bindMaybe;
});

/**
 *  | The `Alt` instance allows for a choice to be made between two `Maybe`
 *  | values with the `<|>` operator, where the first `Just` encountered
 *  | is taken.
 *  |
 *  | ``` purescript
 *  | Just x <|> Just y == Just x
 *  | Nothing <|> Just y == Just y
 *  | Nothing <|> Nothing == Nothing
 *  | ```
 */
var altMaybe = new Control_Alt.Alt(function () {
    return functorMaybe;
}, function (v) {
    return function (v1) {
        if (v instanceof Nothing) {
            return v1;
        };
        return v;
    };
});

/**
 *  | The `Plus` instance provides a default `Maybe` value:
 *  |
 *  | ``` purescript
 *  | empty :: Maybe _ == Nothing
 *  | ```
 */
var plusMaybe = new Control_Plus.Plus(function () {
    return altMaybe;
}, Nothing.value);

/**
 *  | The `Alternative` instance guarantees that there are both `Applicative` and
 *  | `Plus` instances for `Maybe`.
 */
var alternativeMaybe = new Control_Alternative.Alternative(function () {
    return plusMaybe;
}, function () {
    return applicativeMaybe;
});

/**
 *  | The `MonadPlus` instance guarantees that there are both `Monad` and
 *  | `Alternative` instances for `Maybe`.
 */
var monadPlusMaybe = new Control_MonadPlus.MonadPlus(function () {
    return alternativeMaybe;
}, function () {
    return monadMaybe;
});
module.exports = {
    Nothing: Nothing, 
    Just: Just, 
    isNothing: isNothing, 
    isJust: isJust, 
    "fromMaybe'": fromMaybe$prime, 
    fromMaybe: fromMaybe, 
    "maybe'": maybe$prime, 
    maybe: maybe, 
    functorMaybe: functorMaybe, 
    applyMaybe: applyMaybe, 
    applicativeMaybe: applicativeMaybe, 
    altMaybe: altMaybe, 
    plusMaybe: plusMaybe, 
    alternativeMaybe: alternativeMaybe, 
    bindMaybe: bindMaybe, 
    monadMaybe: monadMaybe, 
    monadPlusMaybe: monadPlusMaybe, 
    extendMaybe: extendMaybe, 
    invariantMaybe: invariantMaybe, 
    semigroupMaybe: semigroupMaybe, 
    monoidMaybe: monoidMaybe, 
    semiringMaybe: semiringMaybe, 
    moduloSemiringMaybe: moduloSemiringMaybe, 
    ringMaybe: ringMaybe, 
    divisionRingMaybe: divisionRingMaybe, 
    numMaybe: numMaybe, 
    eqMaybe: eqMaybe, 
    ordMaybe: ordMaybe, 
    boundedMaybe: boundedMaybe, 
    boundedOrdMaybe: boundedOrdMaybe, 
    booleanAlgebraMaybe: booleanAlgebraMaybe, 
    showMaybe: showMaybe
};
