// Generated by psc version 0.8.5.0
"use strict";
var Prelude = require("../Prelude");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_ST = require("../Control.Monad.ST");
var Data_Either = require("../Data.Either");
var Data_Functor = require("../Data.Functor");
var Data_Identity = require("../Data.Identity");
var Control_Monad_Eff_Unsafe = require("../Control.Monad.Eff.Unsafe");
var Data_Either_Unsafe = require("../Data.Either.Unsafe");

/**
 *  | This type class captures those monads which support tail recursion in constant stack space.
 *  |
 *  | The `tailRecM` function takes a step function, and applies that step function recursively
 *  | until a return value of type `b` is found.
 *  |
 *  | Instances are provided for standard monad transformers.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | loopWriter :: Number -> WriterT Sum (Eff (trace :: Trace)) Unit
 *  | loopWriter n = tailRecM go n
 *  |   where
 *  |   go 0 = do
 *  |     lift $ trace "Done!"
 *  |     return (Right unit)
 *  |   go n = do
 *  |     tell $ Sum n
 *  |     return (Left (n - 1))
 *  | ```
 */
var MonadRec = function (__superclass_Prelude$dotMonad_0, tailRecM) {
    this["__superclass_Prelude.Monad_0"] = __superclass_Prelude$dotMonad_0;
    this.tailRecM = tailRecM;
};

/**
 *  | This type class captures those monads which support tail recursion in constant stack space.
 *  |
 *  | The `tailRecM` function takes a step function, and applies that step function recursively
 *  | until a return value of type `b` is found.
 *  |
 *  | Instances are provided for standard monad transformers.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | loopWriter :: Number -> WriterT Sum (Eff (trace :: Trace)) Unit
 *  | loopWriter n = tailRecM go n
 *  |   where
 *  |   go 0 = do
 *  |     lift $ trace "Done!"
 *  |     return (Right unit)
 *  |   go n = do
 *  |     tell $ Sum n
 *  |     return (Left (n - 1))
 *  | ```
 */
var tailRecM = function (dict) {
    return dict.tailRecM;
};

/**
 *  | Create a tail-recursive function of two arguments which uses constant stack space.
 */
var tailRecM2 = function (dictMonadRec) {
    return function (f) {
        return function (a) {
            return function (b) {
                return tailRecM(dictMonadRec)(function (o) {
                    return f(o.a)(o.b);
                })({
                    a: a, 
                    b: b
                });
            };
        };
    };
};

/**
 *  | Create a tail-recursive function of three arguments which uses constant stack space.
 */
var tailRecM3 = function (dictMonadRec) {
    return function (f) {
        return function (a) {
            return function (b) {
                return function (c) {
                    return tailRecM(dictMonadRec)(function (o) {
                        return f(o.a)(o.b)(o.c);
                    })({
                        a: a, 
                        b: b, 
                        c: c
                    });
                };
            };
        };
    };
};
var tailRecEff = function (f) {
    return function (a) {
        var f$prime = function ($18) {
            return Control_Monad_Eff_Unsafe.unsafeInterleaveEff(f($18));
        };
        return function __do() {
            var v = f$prime(a)();
            var v1 = {
                value: v
            };
            (function () {
                while (!(function __do() {
                    var v2 = v1.value;
                    if (v2 instanceof Data_Either.Left) {
                        var v3 = f$prime(v2.value0)();
                        v1.value = v3;
                        return false;
                    };
                    if (v2 instanceof Data_Either.Right) {
                        return true;
                    };
                    throw new Error("Failed pattern match at Control.Monad.Rec.Class line 81, column 5 - line 86, column 3: " + [ v2.constructor.name ]);
                })()) {

                };
                return {};
            })();
            return Prelude["<$>"](Control_Monad_Eff.functorEff)(Data_Either_Unsafe.fromRight)(Control_Monad_ST.readSTRef(v1))();
        };
    };
};

/**
 *  | Create a pure tail-recursive function of one argument
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | pow :: Number -> Number -> Number
 *  | pow n p = tailRec go { accum: 1, power: p }
 *  |   where
 *  |   go :: _ -> Either _ Number
 *  |   go { accum: acc, power: 0 } = Right acc
 *  |   go { accum: acc, power: p } = Left { accum: acc * n, power: p - 1 }
 *  | ```
 */
var tailRec = function (f) {
    return function (a) {
        var go = function (__copy_v) {
            var v = __copy_v;
            tco: while (true) {
                if (v instanceof Data_Either.Left) {
                    var __tco_v = f(v.value0);
                    v = __tco_v;
                    continue tco;
                };
                if (v instanceof Data_Either.Right) {
                    return v.value0;
                };
                throw new Error("Failed pattern match at Control.Monad.Rec.Class line 64, column 1 - line 69, column 1: " + [ v.constructor.name ]);
            };
        };
        return go(f(a));
    };
};
var monadRecIdentity = new MonadRec(function () {
    return Data_Identity.monadIdentity;
}, function (f) {
    return function ($19) {
        return Data_Identity.Identity(tailRec(function ($20) {
            return Data_Identity.runIdentity(f($20));
        })($19));
    };
});
var monadRecEff = new MonadRec(function () {
    return Control_Monad_Eff.monadEff;
}, tailRecEff);

/**
 *  | `forever` runs an action indefinitely, using the `MonadRec` instance to
 *  | ensure constant stack usage.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | main = forever $ trace "Hello, World!"
 *  | ```
 */
var forever = function (dictMonadRec) {
    return function (ma) {
        return tailRecM(dictMonadRec)(function (u) {
            return Data_Functor["<$"]((((dictMonadRec["__superclass_Prelude.Monad_0"]())["__superclass_Prelude.Bind_1"]())["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(new Data_Either.Left(u))(ma);
        })(Prelude.unit);
    };
};
module.exports = {
    MonadRec: MonadRec, 
    forever: forever, 
    tailRecM3: tailRecM3, 
    tailRecM2: tailRecM2, 
    tailRecM: tailRecM, 
    tailRec: tailRec, 
    monadRecIdentity: monadRecIdentity, 
    monadRecEff: monadRecEff
};
